
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model client_pics
 * 
 */
export type client_pics = $Result.DefaultSelection<Prisma.$client_picsPayload>
/**
 * Model clients
 * 
 */
export type clients = $Result.DefaultSelection<Prisma.$clientsPayload>
/**
 * Model documents
 * 
 */
export type documents = $Result.DefaultSelection<Prisma.$documentsPayload>
/**
 * Model employees
 * 
 */
export type employees = $Result.DefaultSelection<Prisma.$employeesPayload>
/**
 * Model project_team_members
 * 
 */
export type project_team_members = $Result.DefaultSelection<Prisma.$project_team_membersPayload>
/**
 * Model project_teams
 * 
 */
export type project_teams = $Result.DefaultSelection<Prisma.$project_teamsPayload>
/**
 * Model projects
 * 
 */
export type projects = $Result.DefaultSelection<Prisma.$projectsPayload>
/**
 * Model role_levels
 * 
 */
export type role_levels = $Result.DefaultSelection<Prisma.$role_levelsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const document_types: {
  BA: 'BA',
  OP: 'OP',
  BAST: 'BAST'
};

export type document_types = (typeof document_types)[keyof typeof document_types]


export const project_types: {
  ET: 'ET',
  FB: 'FB',
  MS: 'MS'
};

export type project_types = (typeof project_types)[keyof typeof project_types]


export const status_employees: {
  freelance: 'freelance',
  active: 'active',
  resigned: 'resigned'
};

export type status_employees = (typeof status_employees)[keyof typeof status_employees]

}

export type document_types = $Enums.document_types

export const document_types: typeof $Enums.document_types

export type project_types = $Enums.project_types

export const project_types: typeof $Enums.project_types

export type status_employees = $Enums.status_employees

export const status_employees: typeof $Enums.status_employees

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Client_pics
 * const client_pics = await prisma.client_pics.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Client_pics
   * const client_pics = await prisma.client_pics.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.client_pics`: Exposes CRUD operations for the **client_pics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Client_pics
    * const client_pics = await prisma.client_pics.findMany()
    * ```
    */
  get client_pics(): Prisma.client_picsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clients`: Exposes CRUD operations for the **clients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.clients.findMany()
    * ```
    */
  get clients(): Prisma.clientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documents`: Exposes CRUD operations for the **documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.documents.findMany()
    * ```
    */
  get documents(): Prisma.documentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): Prisma.employeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project_team_members`: Exposes CRUD operations for the **project_team_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Project_team_members
    * const project_team_members = await prisma.project_team_members.findMany()
    * ```
    */
  get project_team_members(): Prisma.project_team_membersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project_teams`: Exposes CRUD operations for the **project_teams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Project_teams
    * const project_teams = await prisma.project_teams.findMany()
    * ```
    */
  get project_teams(): Prisma.project_teamsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projects`: Exposes CRUD operations for the **projects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.projects.findMany()
    * ```
    */
  get projects(): Prisma.projectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role_levels`: Exposes CRUD operations for the **role_levels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Role_levels
    * const role_levels = await prisma.role_levels.findMany()
    * ```
    */
  get role_levels(): Prisma.role_levelsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    client_pics: 'client_pics',
    clients: 'clients',
    documents: 'documents',
    employees: 'employees',
    project_team_members: 'project_team_members',
    project_teams: 'project_teams',
    projects: 'projects',
    role_levels: 'role_levels'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "client_pics" | "clients" | "documents" | "employees" | "project_team_members" | "project_teams" | "projects" | "role_levels"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      client_pics: {
        payload: Prisma.$client_picsPayload<ExtArgs>
        fields: Prisma.client_picsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.client_picsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.client_picsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>
          }
          findFirst: {
            args: Prisma.client_picsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.client_picsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>
          }
          findMany: {
            args: Prisma.client_picsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>[]
          }
          create: {
            args: Prisma.client_picsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>
          }
          createMany: {
            args: Prisma.client_picsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.client_picsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>[]
          }
          delete: {
            args: Prisma.client_picsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>
          }
          update: {
            args: Prisma.client_picsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>
          }
          deleteMany: {
            args: Prisma.client_picsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.client_picsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.client_picsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>[]
          }
          upsert: {
            args: Prisma.client_picsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$client_picsPayload>
          }
          aggregate: {
            args: Prisma.Client_picsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient_pics>
          }
          groupBy: {
            args: Prisma.client_picsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Client_picsGroupByOutputType>[]
          }
          count: {
            args: Prisma.client_picsCountArgs<ExtArgs>
            result: $Utils.Optional<Client_picsCountAggregateOutputType> | number
          }
        }
      }
      clients: {
        payload: Prisma.$clientsPayload<ExtArgs>
        fields: Prisma.clientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          findFirst: {
            args: Prisma.clientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          findMany: {
            args: Prisma.clientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>[]
          }
          create: {
            args: Prisma.clientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          createMany: {
            args: Prisma.clientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>[]
          }
          delete: {
            args: Prisma.clientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          update: {
            args: Prisma.clientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          deleteMany: {
            args: Prisma.clientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clientsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>[]
          }
          upsert: {
            args: Prisma.clientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          aggregate: {
            args: Prisma.ClientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClients>
          }
          groupBy: {
            args: Prisma.clientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientsCountArgs<ExtArgs>
            result: $Utils.Optional<ClientsCountAggregateOutputType> | number
          }
        }
      }
      documents: {
        payload: Prisma.$documentsPayload<ExtArgs>
        fields: Prisma.documentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.documentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.documentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findFirst: {
            args: Prisma.documentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.documentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          findMany: {
            args: Prisma.documentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          create: {
            args: Prisma.documentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          createMany: {
            args: Prisma.documentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.documentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          delete: {
            args: Prisma.documentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          update: {
            args: Prisma.documentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          deleteMany: {
            args: Prisma.documentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.documentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.documentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>[]
          }
          upsert: {
            args: Prisma.documentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$documentsPayload>
          }
          aggregate: {
            args: Prisma.DocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocuments>
          }
          groupBy: {
            args: Prisma.documentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.documentsCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentsCountAggregateOutputType> | number
          }
        }
      }
      employees: {
        payload: Prisma.$employeesPayload<ExtArgs>
        fields: Prisma.employeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          findFirst: {
            args: Prisma.employeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          findMany: {
            args: Prisma.employeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>[]
          }
          create: {
            args: Prisma.employeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          createMany: {
            args: Prisma.employeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>[]
          }
          delete: {
            args: Prisma.employeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          update: {
            args: Prisma.employeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          deleteMany: {
            args: Prisma.employeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>[]
          }
          upsert: {
            args: Prisma.employeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployees>
          }
          groupBy: {
            args: Prisma.employeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeesCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesCountAggregateOutputType> | number
          }
        }
      }
      project_team_members: {
        payload: Prisma.$project_team_membersPayload<ExtArgs>
        fields: Prisma.project_team_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.project_team_membersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.project_team_membersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>
          }
          findFirst: {
            args: Prisma.project_team_membersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.project_team_membersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>
          }
          findMany: {
            args: Prisma.project_team_membersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>[]
          }
          create: {
            args: Prisma.project_team_membersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>
          }
          createMany: {
            args: Prisma.project_team_membersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.project_team_membersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>[]
          }
          delete: {
            args: Prisma.project_team_membersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>
          }
          update: {
            args: Prisma.project_team_membersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>
          }
          deleteMany: {
            args: Prisma.project_team_membersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.project_team_membersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.project_team_membersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>[]
          }
          upsert: {
            args: Prisma.project_team_membersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_team_membersPayload>
          }
          aggregate: {
            args: Prisma.Project_team_membersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject_team_members>
          }
          groupBy: {
            args: Prisma.project_team_membersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Project_team_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.project_team_membersCountArgs<ExtArgs>
            result: $Utils.Optional<Project_team_membersCountAggregateOutputType> | number
          }
        }
      }
      project_teams: {
        payload: Prisma.$project_teamsPayload<ExtArgs>
        fields: Prisma.project_teamsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.project_teamsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.project_teamsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>
          }
          findFirst: {
            args: Prisma.project_teamsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.project_teamsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>
          }
          findMany: {
            args: Prisma.project_teamsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>[]
          }
          create: {
            args: Prisma.project_teamsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>
          }
          createMany: {
            args: Prisma.project_teamsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.project_teamsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>[]
          }
          delete: {
            args: Prisma.project_teamsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>
          }
          update: {
            args: Prisma.project_teamsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>
          }
          deleteMany: {
            args: Prisma.project_teamsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.project_teamsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.project_teamsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>[]
          }
          upsert: {
            args: Prisma.project_teamsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$project_teamsPayload>
          }
          aggregate: {
            args: Prisma.Project_teamsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject_teams>
          }
          groupBy: {
            args: Prisma.project_teamsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Project_teamsGroupByOutputType>[]
          }
          count: {
            args: Prisma.project_teamsCountArgs<ExtArgs>
            result: $Utils.Optional<Project_teamsCountAggregateOutputType> | number
          }
        }
      }
      projects: {
        payload: Prisma.$projectsPayload<ExtArgs>
        fields: Prisma.projectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          findFirst: {
            args: Prisma.projectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          findMany: {
            args: Prisma.projectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>[]
          }
          create: {
            args: Prisma.projectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          createMany: {
            args: Prisma.projectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>[]
          }
          delete: {
            args: Prisma.projectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          update: {
            args: Prisma.projectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          deleteMany: {
            args: Prisma.projectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projectsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>[]
          }
          upsert: {
            args: Prisma.projectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          aggregate: {
            args: Prisma.ProjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjects>
          }
          groupBy: {
            args: Prisma.projectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.projectsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectsCountAggregateOutputType> | number
          }
        }
      }
      role_levels: {
        payload: Prisma.$role_levelsPayload<ExtArgs>
        fields: Prisma.role_levelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.role_levelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.role_levelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>
          }
          findFirst: {
            args: Prisma.role_levelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.role_levelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>
          }
          findMany: {
            args: Prisma.role_levelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>[]
          }
          create: {
            args: Prisma.role_levelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>
          }
          createMany: {
            args: Prisma.role_levelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.role_levelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>[]
          }
          delete: {
            args: Prisma.role_levelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>
          }
          update: {
            args: Prisma.role_levelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>
          }
          deleteMany: {
            args: Prisma.role_levelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.role_levelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.role_levelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>[]
          }
          upsert: {
            args: Prisma.role_levelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_levelsPayload>
          }
          aggregate: {
            args: Prisma.Role_levelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole_levels>
          }
          groupBy: {
            args: Prisma.role_levelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Role_levelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.role_levelsCountArgs<ExtArgs>
            result: $Utils.Optional<Role_levelsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    client_pics?: client_picsOmit
    clients?: clientsOmit
    documents?: documentsOmit
    employees?: employeesOmit
    project_team_members?: project_team_membersOmit
    project_teams?: project_teamsOmit
    projects?: projectsOmit
    role_levels?: role_levelsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Client_picsCountOutputType
   */

  export type Client_picsCountOutputType = {
    documents: number
  }

  export type Client_picsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | Client_picsCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * Client_picsCountOutputType without action
   */
  export type Client_picsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client_picsCountOutputType
     */
    select?: Client_picsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Client_picsCountOutputType without action
   */
  export type Client_picsCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
  }


  /**
   * Count Type ClientsCountOutputType
   */

  export type ClientsCountOutputType = {
    client_pics: number
    documents: number
    projects: number
  }

  export type ClientsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_pics?: boolean | ClientsCountOutputTypeCountClient_picsArgs
    documents?: boolean | ClientsCountOutputTypeCountDocumentsArgs
    projects?: boolean | ClientsCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientsCountOutputType
     */
    select?: ClientsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountClient_picsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_picsWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectsWhereInput
  }


  /**
   * Count Type EmployeesCountOutputType
   */

  export type EmployeesCountOutputType = {
    project_team_members: number
    project_teams_project_teams_auditor_idToemployees: number
    project_teams_project_teams_manager_idToemployees: number
  }

  export type EmployeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_team_members?: boolean | EmployeesCountOutputTypeCountProject_team_membersArgs
    project_teams_project_teams_auditor_idToemployees?: boolean | EmployeesCountOutputTypeCountProject_teams_project_teams_auditor_idToemployeesArgs
    project_teams_project_teams_manager_idToemployees?: boolean | EmployeesCountOutputTypeCountProject_teams_project_teams_manager_idToemployeesArgs
  }

  // Custom InputTypes
  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesCountOutputType
     */
    select?: EmployeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountProject_team_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_team_membersWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountProject_teams_project_teams_auditor_idToemployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_teamsWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountProject_teams_project_teams_manager_idToemployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_teamsWhereInput
  }


  /**
   * Count Type Project_teamsCountOutputType
   */

  export type Project_teamsCountOutputType = {
    project_team_members: number
  }

  export type Project_teamsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_team_members?: boolean | Project_teamsCountOutputTypeCountProject_team_membersArgs
  }

  // Custom InputTypes
  /**
   * Project_teamsCountOutputType without action
   */
  export type Project_teamsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project_teamsCountOutputType
     */
    select?: Project_teamsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Project_teamsCountOutputType without action
   */
  export type Project_teamsCountOutputTypeCountProject_team_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_team_membersWhereInput
  }


  /**
   * Count Type ProjectsCountOutputType
   */

  export type ProjectsCountOutputType = {
    client_pics: number
    documents: number
    project_teams: number
  }

  export type ProjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_pics?: boolean | ProjectsCountOutputTypeCountClient_picsArgs
    documents?: boolean | ProjectsCountOutputTypeCountDocumentsArgs
    project_teams?: boolean | ProjectsCountOutputTypeCountProject_teamsArgs
  }

  // Custom InputTypes
  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectsCountOutputType
     */
    select?: ProjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountClient_picsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_picsWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
  }

  /**
   * ProjectsCountOutputType without action
   */
  export type ProjectsCountOutputTypeCountProject_teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_teamsWhereInput
  }


  /**
   * Count Type Role_levelsCountOutputType
   */

  export type Role_levelsCountOutputType = {
    project_team_members: number
  }

  export type Role_levelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_team_members?: boolean | Role_levelsCountOutputTypeCountProject_team_membersArgs
  }

  // Custom InputTypes
  /**
   * Role_levelsCountOutputType without action
   */
  export type Role_levelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role_levelsCountOutputType
     */
    select?: Role_levelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Role_levelsCountOutputType without action
   */
  export type Role_levelsCountOutputTypeCountProject_team_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_team_membersWhereInput
  }


  /**
   * Models
   */

  /**
   * Model client_pics
   */

  export type AggregateClient_pics = {
    _count: Client_picsCountAggregateOutputType | null
    _avg: Client_picsAvgAggregateOutputType | null
    _sum: Client_picsSumAggregateOutputType | null
    _min: Client_picsMinAggregateOutputType | null
    _max: Client_picsMaxAggregateOutputType | null
  }

  export type Client_picsAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
    client_id: number | null
  }

  export type Client_picsSumAggregateOutputType = {
    id: number | null
    project_id: number | null
    client_id: number | null
  }

  export type Client_picsMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    title: string | null
    project_id: number | null
    client_id: number | null
  }

  export type Client_picsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    title: string | null
    project_id: number | null
    client_id: number | null
  }

  export type Client_picsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    title: number
    project_id: number
    client_id: number
    _all: number
  }


  export type Client_picsAvgAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
  }

  export type Client_picsSumAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
  }

  export type Client_picsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    title?: true
    project_id?: true
    client_id?: true
  }

  export type Client_picsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    title?: true
    project_id?: true
    client_id?: true
  }

  export type Client_picsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    title?: true
    project_id?: true
    client_id?: true
    _all?: true
  }

  export type Client_picsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_pics to aggregate.
     */
    where?: client_picsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_pics to fetch.
     */
    orderBy?: client_picsOrderByWithRelationInput | client_picsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: client_picsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_pics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_pics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned client_pics
    **/
    _count?: true | Client_picsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Client_picsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Client_picsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Client_picsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Client_picsMaxAggregateInputType
  }

  export type GetClient_picsAggregateType<T extends Client_picsAggregateArgs> = {
        [P in keyof T & keyof AggregateClient_pics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient_pics[P]>
      : GetScalarType<T[P], AggregateClient_pics[P]>
  }




  export type client_picsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: client_picsWhereInput
    orderBy?: client_picsOrderByWithAggregationInput | client_picsOrderByWithAggregationInput[]
    by: Client_picsScalarFieldEnum[] | Client_picsScalarFieldEnum
    having?: client_picsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Client_picsCountAggregateInputType | true
    _avg?: Client_picsAvgAggregateInputType
    _sum?: Client_picsSumAggregateInputType
    _min?: Client_picsMinAggregateInputType
    _max?: Client_picsMaxAggregateInputType
  }

  export type Client_picsGroupByOutputType = {
    id: number
    name: string
    email: string | null
    phone: string | null
    title: string | null
    project_id: number
    client_id: number
    _count: Client_picsCountAggregateOutputType | null
    _avg: Client_picsAvgAggregateOutputType | null
    _sum: Client_picsSumAggregateOutputType | null
    _min: Client_picsMinAggregateOutputType | null
    _max: Client_picsMaxAggregateOutputType | null
  }

  type GetClient_picsGroupByPayload<T extends client_picsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Client_picsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Client_picsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Client_picsGroupByOutputType[P]>
            : GetScalarType<T[P], Client_picsGroupByOutputType[P]>
        }
      >
    >


  export type client_picsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    project_id?: boolean
    client_id?: boolean
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
    documents?: boolean | client_pics$documentsArgs<ExtArgs>
    _count?: boolean | Client_picsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client_pics"]>

  export type client_picsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    project_id?: boolean
    client_id?: boolean
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client_pics"]>

  export type client_picsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    project_id?: boolean
    client_id?: boolean
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client_pics"]>

  export type client_picsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    project_id?: boolean
    client_id?: boolean
  }

  export type client_picsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "title" | "project_id" | "client_id", ExtArgs["result"]["client_pics"]>
  export type client_picsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
    documents?: boolean | client_pics$documentsArgs<ExtArgs>
    _count?: boolean | Client_picsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type client_picsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }
  export type client_picsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }

  export type $client_picsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "client_pics"
    objects: {
      clients: Prisma.$clientsPayload<ExtArgs>
      projects: Prisma.$projectsPayload<ExtArgs>
      documents: Prisma.$documentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string | null
      phone: string | null
      title: string | null
      project_id: number
      client_id: number
    }, ExtArgs["result"]["client_pics"]>
    composites: {}
  }

  type client_picsGetPayload<S extends boolean | null | undefined | client_picsDefaultArgs> = $Result.GetResult<Prisma.$client_picsPayload, S>

  type client_picsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<client_picsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Client_picsCountAggregateInputType | true
    }

  export interface client_picsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['client_pics'], meta: { name: 'client_pics' } }
    /**
     * Find zero or one Client_pics that matches the filter.
     * @param {client_picsFindUniqueArgs} args - Arguments to find a Client_pics
     * @example
     * // Get one Client_pics
     * const client_pics = await prisma.client_pics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends client_picsFindUniqueArgs>(args: SelectSubset<T, client_picsFindUniqueArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client_pics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {client_picsFindUniqueOrThrowArgs} args - Arguments to find a Client_pics
     * @example
     * // Get one Client_pics
     * const client_pics = await prisma.client_pics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends client_picsFindUniqueOrThrowArgs>(args: SelectSubset<T, client_picsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_pics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_picsFindFirstArgs} args - Arguments to find a Client_pics
     * @example
     * // Get one Client_pics
     * const client_pics = await prisma.client_pics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends client_picsFindFirstArgs>(args?: SelectSubset<T, client_picsFindFirstArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client_pics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_picsFindFirstOrThrowArgs} args - Arguments to find a Client_pics
     * @example
     * // Get one Client_pics
     * const client_pics = await prisma.client_pics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends client_picsFindFirstOrThrowArgs>(args?: SelectSubset<T, client_picsFindFirstOrThrowArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Client_pics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_picsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Client_pics
     * const client_pics = await prisma.client_pics.findMany()
     * 
     * // Get first 10 Client_pics
     * const client_pics = await prisma.client_pics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const client_picsWithIdOnly = await prisma.client_pics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends client_picsFindManyArgs>(args?: SelectSubset<T, client_picsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client_pics.
     * @param {client_picsCreateArgs} args - Arguments to create a Client_pics.
     * @example
     * // Create one Client_pics
     * const Client_pics = await prisma.client_pics.create({
     *   data: {
     *     // ... data to create a Client_pics
     *   }
     * })
     * 
     */
    create<T extends client_picsCreateArgs>(args: SelectSubset<T, client_picsCreateArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Client_pics.
     * @param {client_picsCreateManyArgs} args - Arguments to create many Client_pics.
     * @example
     * // Create many Client_pics
     * const client_pics = await prisma.client_pics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends client_picsCreateManyArgs>(args?: SelectSubset<T, client_picsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Client_pics and returns the data saved in the database.
     * @param {client_picsCreateManyAndReturnArgs} args - Arguments to create many Client_pics.
     * @example
     * // Create many Client_pics
     * const client_pics = await prisma.client_pics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Client_pics and only return the `id`
     * const client_picsWithIdOnly = await prisma.client_pics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends client_picsCreateManyAndReturnArgs>(args?: SelectSubset<T, client_picsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client_pics.
     * @param {client_picsDeleteArgs} args - Arguments to delete one Client_pics.
     * @example
     * // Delete one Client_pics
     * const Client_pics = await prisma.client_pics.delete({
     *   where: {
     *     // ... filter to delete one Client_pics
     *   }
     * })
     * 
     */
    delete<T extends client_picsDeleteArgs>(args: SelectSubset<T, client_picsDeleteArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client_pics.
     * @param {client_picsUpdateArgs} args - Arguments to update one Client_pics.
     * @example
     * // Update one Client_pics
     * const client_pics = await prisma.client_pics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends client_picsUpdateArgs>(args: SelectSubset<T, client_picsUpdateArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Client_pics.
     * @param {client_picsDeleteManyArgs} args - Arguments to filter Client_pics to delete.
     * @example
     * // Delete a few Client_pics
     * const { count } = await prisma.client_pics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends client_picsDeleteManyArgs>(args?: SelectSubset<T, client_picsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_pics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_picsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Client_pics
     * const client_pics = await prisma.client_pics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends client_picsUpdateManyArgs>(args: SelectSubset<T, client_picsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Client_pics and returns the data updated in the database.
     * @param {client_picsUpdateManyAndReturnArgs} args - Arguments to update many Client_pics.
     * @example
     * // Update many Client_pics
     * const client_pics = await prisma.client_pics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Client_pics and only return the `id`
     * const client_picsWithIdOnly = await prisma.client_pics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends client_picsUpdateManyAndReturnArgs>(args: SelectSubset<T, client_picsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client_pics.
     * @param {client_picsUpsertArgs} args - Arguments to update or create a Client_pics.
     * @example
     * // Update or create a Client_pics
     * const client_pics = await prisma.client_pics.upsert({
     *   create: {
     *     // ... data to create a Client_pics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client_pics we want to update
     *   }
     * })
     */
    upsert<T extends client_picsUpsertArgs>(args: SelectSubset<T, client_picsUpsertArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Client_pics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_picsCountArgs} args - Arguments to filter Client_pics to count.
     * @example
     * // Count the number of Client_pics
     * const count = await prisma.client_pics.count({
     *   where: {
     *     // ... the filter for the Client_pics we want to count
     *   }
     * })
    **/
    count<T extends client_picsCountArgs>(
      args?: Subset<T, client_picsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Client_picsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client_pics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Client_picsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Client_picsAggregateArgs>(args: Subset<T, Client_picsAggregateArgs>): Prisma.PrismaPromise<GetClient_picsAggregateType<T>>

    /**
     * Group by Client_pics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {client_picsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends client_picsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: client_picsGroupByArgs['orderBy'] }
        : { orderBy?: client_picsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, client_picsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClient_picsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the client_pics model
   */
  readonly fields: client_picsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for client_pics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__client_picsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clients<T extends clientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientsDefaultArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends projectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projectsDefaultArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends client_pics$documentsArgs<ExtArgs> = {}>(args?: Subset<T, client_pics$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the client_pics model
   */
  interface client_picsFieldRefs {
    readonly id: FieldRef<"client_pics", 'Int'>
    readonly name: FieldRef<"client_pics", 'String'>
    readonly email: FieldRef<"client_pics", 'String'>
    readonly phone: FieldRef<"client_pics", 'String'>
    readonly title: FieldRef<"client_pics", 'String'>
    readonly project_id: FieldRef<"client_pics", 'Int'>
    readonly client_id: FieldRef<"client_pics", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * client_pics findUnique
   */
  export type client_picsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * Filter, which client_pics to fetch.
     */
    where: client_picsWhereUniqueInput
  }

  /**
   * client_pics findUniqueOrThrow
   */
  export type client_picsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * Filter, which client_pics to fetch.
     */
    where: client_picsWhereUniqueInput
  }

  /**
   * client_pics findFirst
   */
  export type client_picsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * Filter, which client_pics to fetch.
     */
    where?: client_picsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_pics to fetch.
     */
    orderBy?: client_picsOrderByWithRelationInput | client_picsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_pics.
     */
    cursor?: client_picsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_pics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_pics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_pics.
     */
    distinct?: Client_picsScalarFieldEnum | Client_picsScalarFieldEnum[]
  }

  /**
   * client_pics findFirstOrThrow
   */
  export type client_picsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * Filter, which client_pics to fetch.
     */
    where?: client_picsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_pics to fetch.
     */
    orderBy?: client_picsOrderByWithRelationInput | client_picsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for client_pics.
     */
    cursor?: client_picsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_pics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_pics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of client_pics.
     */
    distinct?: Client_picsScalarFieldEnum | Client_picsScalarFieldEnum[]
  }

  /**
   * client_pics findMany
   */
  export type client_picsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * Filter, which client_pics to fetch.
     */
    where?: client_picsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of client_pics to fetch.
     */
    orderBy?: client_picsOrderByWithRelationInput | client_picsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing client_pics.
     */
    cursor?: client_picsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` client_pics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` client_pics.
     */
    skip?: number
    distinct?: Client_picsScalarFieldEnum | Client_picsScalarFieldEnum[]
  }

  /**
   * client_pics create
   */
  export type client_picsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * The data needed to create a client_pics.
     */
    data: XOR<client_picsCreateInput, client_picsUncheckedCreateInput>
  }

  /**
   * client_pics createMany
   */
  export type client_picsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many client_pics.
     */
    data: client_picsCreateManyInput | client_picsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * client_pics createManyAndReturn
   */
  export type client_picsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * The data used to create many client_pics.
     */
    data: client_picsCreateManyInput | client_picsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * client_pics update
   */
  export type client_picsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * The data needed to update a client_pics.
     */
    data: XOR<client_picsUpdateInput, client_picsUncheckedUpdateInput>
    /**
     * Choose, which client_pics to update.
     */
    where: client_picsWhereUniqueInput
  }

  /**
   * client_pics updateMany
   */
  export type client_picsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update client_pics.
     */
    data: XOR<client_picsUpdateManyMutationInput, client_picsUncheckedUpdateManyInput>
    /**
     * Filter which client_pics to update
     */
    where?: client_picsWhereInput
    /**
     * Limit how many client_pics to update.
     */
    limit?: number
  }

  /**
   * client_pics updateManyAndReturn
   */
  export type client_picsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * The data used to update client_pics.
     */
    data: XOR<client_picsUpdateManyMutationInput, client_picsUncheckedUpdateManyInput>
    /**
     * Filter which client_pics to update
     */
    where?: client_picsWhereInput
    /**
     * Limit how many client_pics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * client_pics upsert
   */
  export type client_picsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * The filter to search for the client_pics to update in case it exists.
     */
    where: client_picsWhereUniqueInput
    /**
     * In case the client_pics found by the `where` argument doesn't exist, create a new client_pics with this data.
     */
    create: XOR<client_picsCreateInput, client_picsUncheckedCreateInput>
    /**
     * In case the client_pics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<client_picsUpdateInput, client_picsUncheckedUpdateInput>
  }

  /**
   * client_pics delete
   */
  export type client_picsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    /**
     * Filter which client_pics to delete.
     */
    where: client_picsWhereUniqueInput
  }

  /**
   * client_pics deleteMany
   */
  export type client_picsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which client_pics to delete
     */
    where?: client_picsWhereInput
    /**
     * Limit how many client_pics to delete.
     */
    limit?: number
  }

  /**
   * client_pics.documents
   */
  export type client_pics$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    cursor?: documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * client_pics without action
   */
  export type client_picsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
  }


  /**
   * Model clients
   */

  export type AggregateClients = {
    _count: ClientsCountAggregateOutputType | null
    _avg: ClientsAvgAggregateOutputType | null
    _sum: ClientsSumAggregateOutputType | null
    _min: ClientsMinAggregateOutputType | null
    _max: ClientsMaxAggregateOutputType | null
  }

  export type ClientsAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientsSumAggregateOutputType = {
    id: number | null
  }

  export type ClientsMinAggregateOutputType = {
    id: number | null
    name: string | null
    masked_description: string | null
    address: string | null
    phone: string | null
    npwp: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    masked_description: string | null
    address: string | null
    phone: string | null
    npwp: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClientsCountAggregateOutputType = {
    id: number
    name: number
    masked_description: number
    address: number
    phone: number
    npwp: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClientsAvgAggregateInputType = {
    id?: true
  }

  export type ClientsSumAggregateInputType = {
    id?: true
  }

  export type ClientsMinAggregateInputType = {
    id?: true
    name?: true
    masked_description?: true
    address?: true
    phone?: true
    npwp?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientsMaxAggregateInputType = {
    id?: true
    name?: true
    masked_description?: true
    address?: true
    phone?: true
    npwp?: true
    created_at?: true
    updated_at?: true
  }

  export type ClientsCountAggregateInputType = {
    id?: true
    name?: true
    masked_description?: true
    address?: true
    phone?: true
    npwp?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to aggregate.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientsMaxAggregateInputType
  }

  export type GetClientsAggregateType<T extends ClientsAggregateArgs> = {
        [P in keyof T & keyof AggregateClients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClients[P]>
      : GetScalarType<T[P], AggregateClients[P]>
  }




  export type clientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientsWhereInput
    orderBy?: clientsOrderByWithAggregationInput | clientsOrderByWithAggregationInput[]
    by: ClientsScalarFieldEnum[] | ClientsScalarFieldEnum
    having?: clientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientsCountAggregateInputType | true
    _avg?: ClientsAvgAggregateInputType
    _sum?: ClientsSumAggregateInputType
    _min?: ClientsMinAggregateInputType
    _max?: ClientsMaxAggregateInputType
  }

  export type ClientsGroupByOutputType = {
    id: number
    name: string
    masked_description: string | null
    address: string | null
    phone: string | null
    npwp: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: ClientsCountAggregateOutputType | null
    _avg: ClientsAvgAggregateOutputType | null
    _sum: ClientsSumAggregateOutputType | null
    _min: ClientsMinAggregateOutputType | null
    _max: ClientsMaxAggregateOutputType | null
  }

  type GetClientsGroupByPayload<T extends clientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientsGroupByOutputType[P]>
            : GetScalarType<T[P], ClientsGroupByOutputType[P]>
        }
      >
    >


  export type clientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    masked_description?: boolean
    address?: boolean
    phone?: boolean
    npwp?: boolean
    created_at?: boolean
    updated_at?: boolean
    client_pics?: boolean | clients$client_picsArgs<ExtArgs>
    documents?: boolean | clients$documentsArgs<ExtArgs>
    projects?: boolean | clients$projectsArgs<ExtArgs>
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clients"]>

  export type clientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    masked_description?: boolean
    address?: boolean
    phone?: boolean
    npwp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["clients"]>

  export type clientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    masked_description?: boolean
    address?: boolean
    phone?: boolean
    npwp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["clients"]>

  export type clientsSelectScalar = {
    id?: boolean
    name?: boolean
    masked_description?: boolean
    address?: boolean
    phone?: boolean
    npwp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type clientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "masked_description" | "address" | "phone" | "npwp" | "created_at" | "updated_at", ExtArgs["result"]["clients"]>
  export type clientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_pics?: boolean | clients$client_picsArgs<ExtArgs>
    documents?: boolean | clients$documentsArgs<ExtArgs>
    projects?: boolean | clients$projectsArgs<ExtArgs>
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clientsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type clientsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $clientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clients"
    objects: {
      client_pics: Prisma.$client_picsPayload<ExtArgs>[]
      documents: Prisma.$documentsPayload<ExtArgs>[]
      projects: Prisma.$projectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      masked_description: string | null
      address: string | null
      phone: string | null
      npwp: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["clients"]>
    composites: {}
  }

  type clientsGetPayload<S extends boolean | null | undefined | clientsDefaultArgs> = $Result.GetResult<Prisma.$clientsPayload, S>

  type clientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientsCountAggregateInputType | true
    }

  export interface clientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clients'], meta: { name: 'clients' } }
    /**
     * Find zero or one Clients that matches the filter.
     * @param {clientsFindUniqueArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientsFindUniqueArgs>(args: SelectSubset<T, clientsFindUniqueArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientsFindUniqueOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientsFindUniqueOrThrowArgs>(args: SelectSubset<T, clientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindFirstArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientsFindFirstArgs>(args?: SelectSubset<T, clientsFindFirstArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindFirstOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientsFindFirstOrThrowArgs>(args?: SelectSubset<T, clientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.clients.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.clients.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientsWithIdOnly = await prisma.clients.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientsFindManyArgs>(args?: SelectSubset<T, clientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clients.
     * @param {clientsCreateArgs} args - Arguments to create a Clients.
     * @example
     * // Create one Clients
     * const Clients = await prisma.clients.create({
     *   data: {
     *     // ... data to create a Clients
     *   }
     * })
     * 
     */
    create<T extends clientsCreateArgs>(args: SelectSubset<T, clientsCreateArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {clientsCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const clients = await prisma.clients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientsCreateManyArgs>(args?: SelectSubset<T, clientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {clientsCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const clients = await prisma.clients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientsWithIdOnly = await prisma.clients.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clientsCreateManyAndReturnArgs>(args?: SelectSubset<T, clientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clients.
     * @param {clientsDeleteArgs} args - Arguments to delete one Clients.
     * @example
     * // Delete one Clients
     * const Clients = await prisma.clients.delete({
     *   where: {
     *     // ... filter to delete one Clients
     *   }
     * })
     * 
     */
    delete<T extends clientsDeleteArgs>(args: SelectSubset<T, clientsDeleteArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clients.
     * @param {clientsUpdateArgs} args - Arguments to update one Clients.
     * @example
     * // Update one Clients
     * const clients = await prisma.clients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientsUpdateArgs>(args: SelectSubset<T, clientsUpdateArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {clientsDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.clients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientsDeleteManyArgs>(args?: SelectSubset<T, clientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const clients = await prisma.clients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientsUpdateManyArgs>(args: SelectSubset<T, clientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {clientsUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const clients = await prisma.clients.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientsWithIdOnly = await prisma.clients.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clientsUpdateManyAndReturnArgs>(args: SelectSubset<T, clientsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clients.
     * @param {clientsUpsertArgs} args - Arguments to update or create a Clients.
     * @example
     * // Update or create a Clients
     * const clients = await prisma.clients.upsert({
     *   create: {
     *     // ... data to create a Clients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clients we want to update
     *   }
     * })
     */
    upsert<T extends clientsUpsertArgs>(args: SelectSubset<T, clientsUpsertArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.clients.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientsCountArgs>(
      args?: Subset<T, clientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientsAggregateArgs>(args: Subset<T, ClientsAggregateArgs>): Prisma.PrismaPromise<GetClientsAggregateType<T>>

    /**
     * Group by Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientsGroupByArgs['orderBy'] }
        : { orderBy?: clientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clients model
   */
  readonly fields: clientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client_pics<T extends clients$client_picsArgs<ExtArgs> = {}>(args?: Subset<T, clients$client_picsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends clients$documentsArgs<ExtArgs> = {}>(args?: Subset<T, clients$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends clients$projectsArgs<ExtArgs> = {}>(args?: Subset<T, clients$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clients model
   */
  interface clientsFieldRefs {
    readonly id: FieldRef<"clients", 'Int'>
    readonly name: FieldRef<"clients", 'String'>
    readonly masked_description: FieldRef<"clients", 'String'>
    readonly address: FieldRef<"clients", 'String'>
    readonly phone: FieldRef<"clients", 'String'>
    readonly npwp: FieldRef<"clients", 'String'>
    readonly created_at: FieldRef<"clients", 'DateTime'>
    readonly updated_at: FieldRef<"clients", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clients findUnique
   */
  export type clientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients findUniqueOrThrow
   */
  export type clientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients findFirst
   */
  export type clientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients findFirstOrThrow
   */
  export type clientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients findMany
   */
  export type clientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients create
   */
  export type clientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The data needed to create a clients.
     */
    data: XOR<clientsCreateInput, clientsUncheckedCreateInput>
  }

  /**
   * clients createMany
   */
  export type clientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clients.
     */
    data: clientsCreateManyInput | clientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clients createManyAndReturn
   */
  export type clientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * The data used to create many clients.
     */
    data: clientsCreateManyInput | clientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clients update
   */
  export type clientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The data needed to update a clients.
     */
    data: XOR<clientsUpdateInput, clientsUncheckedUpdateInput>
    /**
     * Choose, which clients to update.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients updateMany
   */
  export type clientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clients.
     */
    data: XOR<clientsUpdateManyMutationInput, clientsUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientsWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * clients updateManyAndReturn
   */
  export type clientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * The data used to update clients.
     */
    data: XOR<clientsUpdateManyMutationInput, clientsUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientsWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * clients upsert
   */
  export type clientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The filter to search for the clients to update in case it exists.
     */
    where: clientsWhereUniqueInput
    /**
     * In case the clients found by the `where` argument doesn't exist, create a new clients with this data.
     */
    create: XOR<clientsCreateInput, clientsUncheckedCreateInput>
    /**
     * In case the clients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientsUpdateInput, clientsUncheckedUpdateInput>
  }

  /**
   * clients delete
   */
  export type clientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter which clients to delete.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients deleteMany
   */
  export type clientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to delete
     */
    where?: clientsWhereInput
    /**
     * Limit how many clients to delete.
     */
    limit?: number
  }

  /**
   * clients.client_pics
   */
  export type clients$client_picsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    where?: client_picsWhereInput
    orderBy?: client_picsOrderByWithRelationInput | client_picsOrderByWithRelationInput[]
    cursor?: client_picsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Client_picsScalarFieldEnum | Client_picsScalarFieldEnum[]
  }

  /**
   * clients.documents
   */
  export type clients$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    cursor?: documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * clients.projects
   */
  export type clients$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    where?: projectsWhereInput
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    cursor?: projectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * clients without action
   */
  export type clientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
  }


  /**
   * Model documents
   */

  export type AggregateDocuments = {
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  export type DocumentsAvgAggregateOutputType = {
    id: number | null
    project_id: number | null
    client_pic_id: number | null
    client_id: number | null
  }

  export type DocumentsSumAggregateOutputType = {
    id: number | null
    project_id: number | null
    client_pic_id: number | null
    client_id: number | null
  }

  export type DocumentsMinAggregateOutputType = {
    id: number | null
    document_types: $Enums.document_types | null
    number: string | null
    date_created: Date | null
    date_signed: Date | null
    document_url: string | null
    project_id: number | null
    client_pic_id: number | null
    client_id: number | null
  }

  export type DocumentsMaxAggregateOutputType = {
    id: number | null
    document_types: $Enums.document_types | null
    number: string | null
    date_created: Date | null
    date_signed: Date | null
    document_url: string | null
    project_id: number | null
    client_pic_id: number | null
    client_id: number | null
  }

  export type DocumentsCountAggregateOutputType = {
    id: number
    document_types: number
    number: number
    date_created: number
    date_signed: number
    document_url: number
    project_id: number
    client_pic_id: number
    client_id: number
    _all: number
  }


  export type DocumentsAvgAggregateInputType = {
    id?: true
    project_id?: true
    client_pic_id?: true
    client_id?: true
  }

  export type DocumentsSumAggregateInputType = {
    id?: true
    project_id?: true
    client_pic_id?: true
    client_id?: true
  }

  export type DocumentsMinAggregateInputType = {
    id?: true
    document_types?: true
    number?: true
    date_created?: true
    date_signed?: true
    document_url?: true
    project_id?: true
    client_pic_id?: true
    client_id?: true
  }

  export type DocumentsMaxAggregateInputType = {
    id?: true
    document_types?: true
    number?: true
    date_created?: true
    date_signed?: true
    document_url?: true
    project_id?: true
    client_pic_id?: true
    client_id?: true
  }

  export type DocumentsCountAggregateInputType = {
    id?: true
    document_types?: true
    number?: true
    date_created?: true
    date_signed?: true
    document_url?: true
    project_id?: true
    client_pic_id?: true
    client_id?: true
    _all?: true
  }

  export type DocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to aggregate.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned documents
    **/
    _count?: true | DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentsMaxAggregateInputType
  }

  export type GetDocumentsAggregateType<T extends DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocuments[P]>
      : GetScalarType<T[P], AggregateDocuments[P]>
  }




  export type documentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithAggregationInput | documentsOrderByWithAggregationInput[]
    by: DocumentsScalarFieldEnum[] | DocumentsScalarFieldEnum
    having?: documentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentsCountAggregateInputType | true
    _avg?: DocumentsAvgAggregateInputType
    _sum?: DocumentsSumAggregateInputType
    _min?: DocumentsMinAggregateInputType
    _max?: DocumentsMaxAggregateInputType
  }

  export type DocumentsGroupByOutputType = {
    id: number
    document_types: $Enums.document_types | null
    number: string
    date_created: Date | null
    date_signed: Date | null
    document_url: string | null
    project_id: number
    client_pic_id: number
    client_id: number
    _count: DocumentsCountAggregateOutputType | null
    _avg: DocumentsAvgAggregateOutputType | null
    _sum: DocumentsSumAggregateOutputType | null
    _min: DocumentsMinAggregateOutputType | null
    _max: DocumentsMaxAggregateOutputType | null
  }

  type GetDocumentsGroupByPayload<T extends documentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentsGroupByOutputType[P]>
        }
      >
    >


  export type documentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    document_types?: boolean
    number?: boolean
    date_created?: boolean
    date_signed?: boolean
    document_url?: boolean
    project_id?: boolean
    client_pic_id?: boolean
    client_id?: boolean
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    client_pics?: boolean | client_picsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documents"]>

  export type documentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    document_types?: boolean
    number?: boolean
    date_created?: boolean
    date_signed?: boolean
    document_url?: boolean
    project_id?: boolean
    client_pic_id?: boolean
    client_id?: boolean
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    client_pics?: boolean | client_picsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documents"]>

  export type documentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    document_types?: boolean
    number?: boolean
    date_created?: boolean
    date_signed?: boolean
    document_url?: boolean
    project_id?: boolean
    client_pic_id?: boolean
    client_id?: boolean
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    client_pics?: boolean | client_picsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documents"]>

  export type documentsSelectScalar = {
    id?: boolean
    document_types?: boolean
    number?: boolean
    date_created?: boolean
    date_signed?: boolean
    document_url?: boolean
    project_id?: boolean
    client_pic_id?: boolean
    client_id?: boolean
  }

  export type documentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "document_types" | "number" | "date_created" | "date_signed" | "document_url" | "project_id" | "client_pic_id" | "client_id", ExtArgs["result"]["documents"]>
  export type documentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    client_pics?: boolean | client_picsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }
  export type documentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    client_pics?: boolean | client_picsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }
  export type documentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    client_pics?: boolean | client_picsDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }

  export type $documentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "documents"
    objects: {
      clients: Prisma.$clientsPayload<ExtArgs>
      client_pics: Prisma.$client_picsPayload<ExtArgs>
      projects: Prisma.$projectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      document_types: $Enums.document_types | null
      number: string
      date_created: Date | null
      date_signed: Date | null
      document_url: string | null
      project_id: number
      client_pic_id: number
      client_id: number
    }, ExtArgs["result"]["documents"]>
    composites: {}
  }

  type documentsGetPayload<S extends boolean | null | undefined | documentsDefaultArgs> = $Result.GetResult<Prisma.$documentsPayload, S>

  type documentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<documentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentsCountAggregateInputType | true
    }

  export interface documentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['documents'], meta: { name: 'documents' } }
    /**
     * Find zero or one Documents that matches the filter.
     * @param {documentsFindUniqueArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends documentsFindUniqueArgs>(args: SelectSubset<T, documentsFindUniqueArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documents that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {documentsFindUniqueOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends documentsFindUniqueOrThrowArgs>(args: SelectSubset<T, documentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends documentsFindFirstArgs>(args?: SelectSubset<T, documentsFindFirstArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindFirstOrThrowArgs} args - Arguments to find a Documents
     * @example
     * // Get one Documents
     * const documents = await prisma.documents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends documentsFindFirstOrThrowArgs>(args?: SelectSubset<T, documentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.documents.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentsWithIdOnly = await prisma.documents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends documentsFindManyArgs>(args?: SelectSubset<T, documentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documents.
     * @param {documentsCreateArgs} args - Arguments to create a Documents.
     * @example
     * // Create one Documents
     * const Documents = await prisma.documents.create({
     *   data: {
     *     // ... data to create a Documents
     *   }
     * })
     * 
     */
    create<T extends documentsCreateArgs>(args: SelectSubset<T, documentsCreateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {documentsCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends documentsCreateManyArgs>(args?: SelectSubset<T, documentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {documentsCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const documents = await prisma.documents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentsWithIdOnly = await prisma.documents.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends documentsCreateManyAndReturnArgs>(args?: SelectSubset<T, documentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Documents.
     * @param {documentsDeleteArgs} args - Arguments to delete one Documents.
     * @example
     * // Delete one Documents
     * const Documents = await prisma.documents.delete({
     *   where: {
     *     // ... filter to delete one Documents
     *   }
     * })
     * 
     */
    delete<T extends documentsDeleteArgs>(args: SelectSubset<T, documentsDeleteArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documents.
     * @param {documentsUpdateArgs} args - Arguments to update one Documents.
     * @example
     * // Update one Documents
     * const documents = await prisma.documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends documentsUpdateArgs>(args: SelectSubset<T, documentsUpdateArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {documentsDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends documentsDeleteManyArgs>(args?: SelectSubset<T, documentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends documentsUpdateManyArgs>(args: SelectSubset<T, documentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {documentsUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const documents = await prisma.documents.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentsWithIdOnly = await prisma.documents.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends documentsUpdateManyAndReturnArgs>(args: SelectSubset<T, documentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Documents.
     * @param {documentsUpsertArgs} args - Arguments to update or create a Documents.
     * @example
     * // Update or create a Documents
     * const documents = await prisma.documents.upsert({
     *   create: {
     *     // ... data to create a Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documents we want to update
     *   }
     * })
     */
    upsert<T extends documentsUpsertArgs>(args: SelectSubset<T, documentsUpsertArgs<ExtArgs>>): Prisma__documentsClient<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.documents.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends documentsCountArgs>(
      args?: Subset<T, documentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentsAggregateArgs>(args: Subset<T, DocumentsAggregateArgs>): Prisma.PrismaPromise<GetDocumentsAggregateType<T>>

    /**
     * Group by Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {documentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends documentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: documentsGroupByArgs['orderBy'] }
        : { orderBy?: documentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, documentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the documents model
   */
  readonly fields: documentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__documentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clients<T extends clientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientsDefaultArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client_pics<T extends client_picsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, client_picsDefaultArgs<ExtArgs>>): Prisma__client_picsClient<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends projectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projectsDefaultArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the documents model
   */
  interface documentsFieldRefs {
    readonly id: FieldRef<"documents", 'Int'>
    readonly document_types: FieldRef<"documents", 'document_types'>
    readonly number: FieldRef<"documents", 'String'>
    readonly date_created: FieldRef<"documents", 'DateTime'>
    readonly date_signed: FieldRef<"documents", 'DateTime'>
    readonly document_url: FieldRef<"documents", 'String'>
    readonly project_id: FieldRef<"documents", 'Int'>
    readonly client_pic_id: FieldRef<"documents", 'Int'>
    readonly client_id: FieldRef<"documents", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * documents findUnique
   */
  export type documentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findUniqueOrThrow
   */
  export type documentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents findFirst
   */
  export type documentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findFirstOrThrow
   */
  export type documentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of documents.
     */
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents findMany
   */
  export type documentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter, which documents to fetch.
     */
    where?: documentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of documents to fetch.
     */
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing documents.
     */
    cursor?: documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` documents.
     */
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * documents create
   */
  export type documentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * The data needed to create a documents.
     */
    data: XOR<documentsCreateInput, documentsUncheckedCreateInput>
  }

  /**
   * documents createMany
   */
  export type documentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many documents.
     */
    data: documentsCreateManyInput | documentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * documents createManyAndReturn
   */
  export type documentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The data used to create many documents.
     */
    data: documentsCreateManyInput | documentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * documents update
   */
  export type documentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * The data needed to update a documents.
     */
    data: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
    /**
     * Choose, which documents to update.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents updateMany
   */
  export type documentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update documents.
     */
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyInput>
    /**
     * Filter which documents to update
     */
    where?: documentsWhereInput
    /**
     * Limit how many documents to update.
     */
    limit?: number
  }

  /**
   * documents updateManyAndReturn
   */
  export type documentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * The data used to update documents.
     */
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyInput>
    /**
     * Filter which documents to update
     */
    where?: documentsWhereInput
    /**
     * Limit how many documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * documents upsert
   */
  export type documentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * The filter to search for the documents to update in case it exists.
     */
    where: documentsWhereUniqueInput
    /**
     * In case the documents found by the `where` argument doesn't exist, create a new documents with this data.
     */
    create: XOR<documentsCreateInput, documentsUncheckedCreateInput>
    /**
     * In case the documents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<documentsUpdateInput, documentsUncheckedUpdateInput>
  }

  /**
   * documents delete
   */
  export type documentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    /**
     * Filter which documents to delete.
     */
    where: documentsWhereUniqueInput
  }

  /**
   * documents deleteMany
   */
  export type documentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which documents to delete
     */
    where?: documentsWhereInput
    /**
     * Limit how many documents to delete.
     */
    limit?: number
  }

  /**
   * documents without action
   */
  export type documentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
  }


  /**
   * Model employees
   */

  export type AggregateEmployees = {
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  export type EmployeesAvgAggregateOutputType = {
    id: number | null
  }

  export type EmployeesSumAggregateOutputType = {
    id: number | null
  }

  export type EmployeesMinAggregateOutputType = {
    id: number | null
    nik: string | null
    nip: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    position: string | null
    status: $Enums.status_employees | null
    password: string | null
    refresh_token: string | null
  }

  export type EmployeesMaxAggregateOutputType = {
    id: number | null
    nik: string | null
    nip: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    position: string | null
    status: $Enums.status_employees | null
    password: string | null
    refresh_token: string | null
  }

  export type EmployeesCountAggregateOutputType = {
    id: number
    nik: number
    nip: number
    name: number
    email: number
    phone: number
    address: number
    position: number
    status: number
    password: number
    refresh_token: number
    _all: number
  }


  export type EmployeesAvgAggregateInputType = {
    id?: true
  }

  export type EmployeesSumAggregateInputType = {
    id?: true
  }

  export type EmployeesMinAggregateInputType = {
    id?: true
    nik?: true
    nip?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    position?: true
    status?: true
    password?: true
    refresh_token?: true
  }

  export type EmployeesMaxAggregateInputType = {
    id?: true
    nik?: true
    nip?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    position?: true
    status?: true
    password?: true
    refresh_token?: true
  }

  export type EmployeesCountAggregateInputType = {
    id?: true
    nik?: true
    nip?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    position?: true
    status?: true
    password?: true
    refresh_token?: true
    _all?: true
  }

  export type EmployeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to aggregate.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesMaxAggregateInputType
  }

  export type GetEmployeesAggregateType<T extends EmployeesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployees[P]>
      : GetScalarType<T[P], AggregateEmployees[P]>
  }




  export type employeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeesWhereInput
    orderBy?: employeesOrderByWithAggregationInput | employeesOrderByWithAggregationInput[]
    by: EmployeesScalarFieldEnum[] | EmployeesScalarFieldEnum
    having?: employeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesCountAggregateInputType | true
    _avg?: EmployeesAvgAggregateInputType
    _sum?: EmployeesSumAggregateInputType
    _min?: EmployeesMinAggregateInputType
    _max?: EmployeesMaxAggregateInputType
  }

  export type EmployeesGroupByOutputType = {
    id: number
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password: string | null
    refresh_token: string | null
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  type GetEmployeesGroupByPayload<T extends employeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
        }
      >
    >


  export type employeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nik?: boolean
    nip?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    position?: boolean
    status?: boolean
    password?: boolean
    refresh_token?: boolean
    project_team_members?: boolean | employees$project_team_membersArgs<ExtArgs>
    project_teams_project_teams_auditor_idToemployees?: boolean | employees$project_teams_project_teams_auditor_idToemployeesArgs<ExtArgs>
    project_teams_project_teams_manager_idToemployees?: boolean | employees$project_teams_project_teams_manager_idToemployeesArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type employeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nik?: boolean
    nip?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    position?: boolean
    status?: boolean
    password?: boolean
    refresh_token?: boolean
  }, ExtArgs["result"]["employees"]>

  export type employeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nik?: boolean
    nip?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    position?: boolean
    status?: boolean
    password?: boolean
    refresh_token?: boolean
  }, ExtArgs["result"]["employees"]>

  export type employeesSelectScalar = {
    id?: boolean
    nik?: boolean
    nip?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    position?: boolean
    status?: boolean
    password?: boolean
    refresh_token?: boolean
  }

  export type employeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nik" | "nip" | "name" | "email" | "phone" | "address" | "position" | "status" | "password" | "refresh_token", ExtArgs["result"]["employees"]>
  export type employeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_team_members?: boolean | employees$project_team_membersArgs<ExtArgs>
    project_teams_project_teams_auditor_idToemployees?: boolean | employees$project_teams_project_teams_auditor_idToemployeesArgs<ExtArgs>
    project_teams_project_teams_manager_idToemployees?: boolean | employees$project_teams_project_teams_manager_idToemployeesArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type employeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type employeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $employeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employees"
    objects: {
      project_team_members: Prisma.$project_team_membersPayload<ExtArgs>[]
      project_teams_project_teams_auditor_idToemployees: Prisma.$project_teamsPayload<ExtArgs>[]
      project_teams_project_teams_manager_idToemployees: Prisma.$project_teamsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nik: string
      nip: string
      name: string
      email: string
      phone: string
      address: string
      position: string
      status: $Enums.status_employees
      password: string | null
      refresh_token: string | null
    }, ExtArgs["result"]["employees"]>
    composites: {}
  }

  type employeesGetPayload<S extends boolean | null | undefined | employeesDefaultArgs> = $Result.GetResult<Prisma.$employeesPayload, S>

  type employeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeesCountAggregateInputType | true
    }

  export interface employeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employees'], meta: { name: 'employees' } }
    /**
     * Find zero or one Employees that matches the filter.
     * @param {employeesFindUniqueArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeesFindUniqueArgs>(args: SelectSubset<T, employeesFindUniqueArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeesFindUniqueOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeesFindUniqueOrThrowArgs>(args: SelectSubset<T, employeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindFirstArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeesFindFirstArgs>(args?: SelectSubset<T, employeesFindFirstArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindFirstOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeesFindFirstOrThrowArgs>(args?: SelectSubset<T, employeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employees.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeesWithIdOnly = await prisma.employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employeesFindManyArgs>(args?: SelectSubset<T, employeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employees.
     * @param {employeesCreateArgs} args - Arguments to create a Employees.
     * @example
     * // Create one Employees
     * const Employees = await prisma.employees.create({
     *   data: {
     *     // ... data to create a Employees
     *   }
     * })
     * 
     */
    create<T extends employeesCreateArgs>(args: SelectSubset<T, employeesCreateArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {employeesCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeesCreateManyArgs>(args?: SelectSubset<T, employeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {employeesCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employeesCreateManyAndReturnArgs>(args?: SelectSubset<T, employeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employees.
     * @param {employeesDeleteArgs} args - Arguments to delete one Employees.
     * @example
     * // Delete one Employees
     * const Employees = await prisma.employees.delete({
     *   where: {
     *     // ... filter to delete one Employees
     *   }
     * })
     * 
     */
    delete<T extends employeesDeleteArgs>(args: SelectSubset<T, employeesDeleteArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employees.
     * @param {employeesUpdateArgs} args - Arguments to update one Employees.
     * @example
     * // Update one Employees
     * const employees = await prisma.employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeesUpdateArgs>(args: SelectSubset<T, employeesUpdateArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {employeesDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeesDeleteManyArgs>(args?: SelectSubset<T, employeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeesUpdateManyArgs>(args: SelectSubset<T, employeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {employeesUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employeesUpdateManyAndReturnArgs>(args: SelectSubset<T, employeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employees.
     * @param {employeesUpsertArgs} args - Arguments to update or create a Employees.
     * @example
     * // Update or create a Employees
     * const employees = await prisma.employees.upsert({
     *   create: {
     *     // ... data to create a Employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employees we want to update
     *   }
     * })
     */
    upsert<T extends employeesUpsertArgs>(args: SelectSubset<T, employeesUpsertArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employees.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeesCountArgs>(
      args?: Subset<T, employeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAggregateArgs>(args: Subset<T, EmployeesAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAggregateType<T>>

    /**
     * Group by Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeesGroupByArgs['orderBy'] }
        : { orderBy?: employeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employees model
   */
  readonly fields: employeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project_team_members<T extends employees$project_team_membersArgs<ExtArgs> = {}>(args?: Subset<T, employees$project_team_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project_teams_project_teams_auditor_idToemployees<T extends employees$project_teams_project_teams_auditor_idToemployeesArgs<ExtArgs> = {}>(args?: Subset<T, employees$project_teams_project_teams_auditor_idToemployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project_teams_project_teams_manager_idToemployees<T extends employees$project_teams_project_teams_manager_idToemployeesArgs<ExtArgs> = {}>(args?: Subset<T, employees$project_teams_project_teams_manager_idToemployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employees model
   */
  interface employeesFieldRefs {
    readonly id: FieldRef<"employees", 'Int'>
    readonly nik: FieldRef<"employees", 'String'>
    readonly nip: FieldRef<"employees", 'String'>
    readonly name: FieldRef<"employees", 'String'>
    readonly email: FieldRef<"employees", 'String'>
    readonly phone: FieldRef<"employees", 'String'>
    readonly address: FieldRef<"employees", 'String'>
    readonly position: FieldRef<"employees", 'String'>
    readonly status: FieldRef<"employees", 'status_employees'>
    readonly password: FieldRef<"employees", 'String'>
    readonly refresh_token: FieldRef<"employees", 'String'>
  }
    

  // Custom InputTypes
  /**
   * employees findUnique
   */
  export type employeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees findUniqueOrThrow
   */
  export type employeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees findFirst
   */
  export type employeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees findFirstOrThrow
   */
  export type employeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees findMany
   */
  export type employeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees create
   */
  export type employeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The data needed to create a employees.
     */
    data: XOR<employeesCreateInput, employeesUncheckedCreateInput>
  }

  /**
   * employees createMany
   */
  export type employeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeesCreateManyInput | employeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employees createManyAndReturn
   */
  export type employeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * The data used to create many employees.
     */
    data: employeesCreateManyInput | employeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employees update
   */
  export type employeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The data needed to update a employees.
     */
    data: XOR<employeesUpdateInput, employeesUncheckedUpdateInput>
    /**
     * Choose, which employees to update.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees updateMany
   */
  export type employeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeesUpdateManyMutationInput, employeesUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeesWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employees updateManyAndReturn
   */
  export type employeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * The data used to update employees.
     */
    data: XOR<employeesUpdateManyMutationInput, employeesUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeesWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employees upsert
   */
  export type employeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The filter to search for the employees to update in case it exists.
     */
    where: employeesWhereUniqueInput
    /**
     * In case the employees found by the `where` argument doesn't exist, create a new employees with this data.
     */
    create: XOR<employeesCreateInput, employeesUncheckedCreateInput>
    /**
     * In case the employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeesUpdateInput, employeesUncheckedUpdateInput>
  }

  /**
   * employees delete
   */
  export type employeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter which employees to delete.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees deleteMany
   */
  export type employeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeesWhereInput
    /**
     * Limit how many employees to delete.
     */
    limit?: number
  }

  /**
   * employees.project_team_members
   */
  export type employees$project_team_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    where?: project_team_membersWhereInput
    orderBy?: project_team_membersOrderByWithRelationInput | project_team_membersOrderByWithRelationInput[]
    cursor?: project_team_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Project_team_membersScalarFieldEnum | Project_team_membersScalarFieldEnum[]
  }

  /**
   * employees.project_teams_project_teams_auditor_idToemployees
   */
  export type employees$project_teams_project_teams_auditor_idToemployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    where?: project_teamsWhereInput
    orderBy?: project_teamsOrderByWithRelationInput | project_teamsOrderByWithRelationInput[]
    cursor?: project_teamsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Project_teamsScalarFieldEnum | Project_teamsScalarFieldEnum[]
  }

  /**
   * employees.project_teams_project_teams_manager_idToemployees
   */
  export type employees$project_teams_project_teams_manager_idToemployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    where?: project_teamsWhereInput
    orderBy?: project_teamsOrderByWithRelationInput | project_teamsOrderByWithRelationInput[]
    cursor?: project_teamsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Project_teamsScalarFieldEnum | Project_teamsScalarFieldEnum[]
  }

  /**
   * employees without action
   */
  export type employeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
  }


  /**
   * Model project_team_members
   */

  export type AggregateProject_team_members = {
    _count: Project_team_membersCountAggregateOutputType | null
    _avg: Project_team_membersAvgAggregateOutputType | null
    _sum: Project_team_membersSumAggregateOutputType | null
    _min: Project_team_membersMinAggregateOutputType | null
    _max: Project_team_membersMaxAggregateOutputType | null
  }

  export type Project_team_membersAvgAggregateOutputType = {
    id: number | null
    role_id: number | null
    project_teams_id: number | null
    employee_id: number | null
  }

  export type Project_team_membersSumAggregateOutputType = {
    id: number | null
    role_id: number | null
    project_teams_id: number | null
    employee_id: number | null
  }

  export type Project_team_membersMinAggregateOutputType = {
    id: number | null
    role_id: number | null
    project_teams_id: number | null
    job_description: string | null
    end_at: Date | null
    employee_id: number | null
  }

  export type Project_team_membersMaxAggregateOutputType = {
    id: number | null
    role_id: number | null
    project_teams_id: number | null
    job_description: string | null
    end_at: Date | null
    employee_id: number | null
  }

  export type Project_team_membersCountAggregateOutputType = {
    id: number
    role_id: number
    project_teams_id: number
    job_description: number
    end_at: number
    employee_id: number
    _all: number
  }


  export type Project_team_membersAvgAggregateInputType = {
    id?: true
    role_id?: true
    project_teams_id?: true
    employee_id?: true
  }

  export type Project_team_membersSumAggregateInputType = {
    id?: true
    role_id?: true
    project_teams_id?: true
    employee_id?: true
  }

  export type Project_team_membersMinAggregateInputType = {
    id?: true
    role_id?: true
    project_teams_id?: true
    job_description?: true
    end_at?: true
    employee_id?: true
  }

  export type Project_team_membersMaxAggregateInputType = {
    id?: true
    role_id?: true
    project_teams_id?: true
    job_description?: true
    end_at?: true
    employee_id?: true
  }

  export type Project_team_membersCountAggregateInputType = {
    id?: true
    role_id?: true
    project_teams_id?: true
    job_description?: true
    end_at?: true
    employee_id?: true
    _all?: true
  }

  export type Project_team_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_team_members to aggregate.
     */
    where?: project_team_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_team_members to fetch.
     */
    orderBy?: project_team_membersOrderByWithRelationInput | project_team_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: project_team_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned project_team_members
    **/
    _count?: true | Project_team_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Project_team_membersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Project_team_membersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Project_team_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Project_team_membersMaxAggregateInputType
  }

  export type GetProject_team_membersAggregateType<T extends Project_team_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateProject_team_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject_team_members[P]>
      : GetScalarType<T[P], AggregateProject_team_members[P]>
  }




  export type project_team_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_team_membersWhereInput
    orderBy?: project_team_membersOrderByWithAggregationInput | project_team_membersOrderByWithAggregationInput[]
    by: Project_team_membersScalarFieldEnum[] | Project_team_membersScalarFieldEnum
    having?: project_team_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Project_team_membersCountAggregateInputType | true
    _avg?: Project_team_membersAvgAggregateInputType
    _sum?: Project_team_membersSumAggregateInputType
    _min?: Project_team_membersMinAggregateInputType
    _max?: Project_team_membersMaxAggregateInputType
  }

  export type Project_team_membersGroupByOutputType = {
    id: number
    role_id: number
    project_teams_id: number
    job_description: string | null
    end_at: Date | null
    employee_id: number
    _count: Project_team_membersCountAggregateOutputType | null
    _avg: Project_team_membersAvgAggregateOutputType | null
    _sum: Project_team_membersSumAggregateOutputType | null
    _min: Project_team_membersMinAggregateOutputType | null
    _max: Project_team_membersMaxAggregateOutputType | null
  }

  type GetProject_team_membersGroupByPayload<T extends project_team_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Project_team_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Project_team_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Project_team_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Project_team_membersGroupByOutputType[P]>
        }
      >
    >


  export type project_team_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    project_teams_id?: boolean
    job_description?: boolean
    end_at?: boolean
    employee_id?: boolean
    employees?: boolean | employeesDefaultArgs<ExtArgs>
    project_teams?: boolean | project_teamsDefaultArgs<ExtArgs>
    role_levels?: boolean | role_levelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_team_members"]>

  export type project_team_membersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    project_teams_id?: boolean
    job_description?: boolean
    end_at?: boolean
    employee_id?: boolean
    employees?: boolean | employeesDefaultArgs<ExtArgs>
    project_teams?: boolean | project_teamsDefaultArgs<ExtArgs>
    role_levels?: boolean | role_levelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_team_members"]>

  export type project_team_membersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_id?: boolean
    project_teams_id?: boolean
    job_description?: boolean
    end_at?: boolean
    employee_id?: boolean
    employees?: boolean | employeesDefaultArgs<ExtArgs>
    project_teams?: boolean | project_teamsDefaultArgs<ExtArgs>
    role_levels?: boolean | role_levelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_team_members"]>

  export type project_team_membersSelectScalar = {
    id?: boolean
    role_id?: boolean
    project_teams_id?: boolean
    job_description?: boolean
    end_at?: boolean
    employee_id?: boolean
  }

  export type project_team_membersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role_id" | "project_teams_id" | "job_description" | "end_at" | "employee_id", ExtArgs["result"]["project_team_members"]>
  export type project_team_membersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | employeesDefaultArgs<ExtArgs>
    project_teams?: boolean | project_teamsDefaultArgs<ExtArgs>
    role_levels?: boolean | role_levelsDefaultArgs<ExtArgs>
  }
  export type project_team_membersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | employeesDefaultArgs<ExtArgs>
    project_teams?: boolean | project_teamsDefaultArgs<ExtArgs>
    role_levels?: boolean | role_levelsDefaultArgs<ExtArgs>
  }
  export type project_team_membersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | employeesDefaultArgs<ExtArgs>
    project_teams?: boolean | project_teamsDefaultArgs<ExtArgs>
    role_levels?: boolean | role_levelsDefaultArgs<ExtArgs>
  }

  export type $project_team_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "project_team_members"
    objects: {
      employees: Prisma.$employeesPayload<ExtArgs>
      project_teams: Prisma.$project_teamsPayload<ExtArgs>
      role_levels: Prisma.$role_levelsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role_id: number
      project_teams_id: number
      job_description: string | null
      end_at: Date | null
      employee_id: number
    }, ExtArgs["result"]["project_team_members"]>
    composites: {}
  }

  type project_team_membersGetPayload<S extends boolean | null | undefined | project_team_membersDefaultArgs> = $Result.GetResult<Prisma.$project_team_membersPayload, S>

  type project_team_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<project_team_membersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Project_team_membersCountAggregateInputType | true
    }

  export interface project_team_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['project_team_members'], meta: { name: 'project_team_members' } }
    /**
     * Find zero or one Project_team_members that matches the filter.
     * @param {project_team_membersFindUniqueArgs} args - Arguments to find a Project_team_members
     * @example
     * // Get one Project_team_members
     * const project_team_members = await prisma.project_team_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends project_team_membersFindUniqueArgs>(args: SelectSubset<T, project_team_membersFindUniqueArgs<ExtArgs>>): Prisma__project_team_membersClient<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project_team_members that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {project_team_membersFindUniqueOrThrowArgs} args - Arguments to find a Project_team_members
     * @example
     * // Get one Project_team_members
     * const project_team_members = await prisma.project_team_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends project_team_membersFindUniqueOrThrowArgs>(args: SelectSubset<T, project_team_membersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__project_team_membersClient<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project_team_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_team_membersFindFirstArgs} args - Arguments to find a Project_team_members
     * @example
     * // Get one Project_team_members
     * const project_team_members = await prisma.project_team_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends project_team_membersFindFirstArgs>(args?: SelectSubset<T, project_team_membersFindFirstArgs<ExtArgs>>): Prisma__project_team_membersClient<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project_team_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_team_membersFindFirstOrThrowArgs} args - Arguments to find a Project_team_members
     * @example
     * // Get one Project_team_members
     * const project_team_members = await prisma.project_team_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends project_team_membersFindFirstOrThrowArgs>(args?: SelectSubset<T, project_team_membersFindFirstOrThrowArgs<ExtArgs>>): Prisma__project_team_membersClient<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Project_team_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_team_membersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Project_team_members
     * const project_team_members = await prisma.project_team_members.findMany()
     * 
     * // Get first 10 Project_team_members
     * const project_team_members = await prisma.project_team_members.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const project_team_membersWithIdOnly = await prisma.project_team_members.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends project_team_membersFindManyArgs>(args?: SelectSubset<T, project_team_membersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project_team_members.
     * @param {project_team_membersCreateArgs} args - Arguments to create a Project_team_members.
     * @example
     * // Create one Project_team_members
     * const Project_team_members = await prisma.project_team_members.create({
     *   data: {
     *     // ... data to create a Project_team_members
     *   }
     * })
     * 
     */
    create<T extends project_team_membersCreateArgs>(args: SelectSubset<T, project_team_membersCreateArgs<ExtArgs>>): Prisma__project_team_membersClient<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Project_team_members.
     * @param {project_team_membersCreateManyArgs} args - Arguments to create many Project_team_members.
     * @example
     * // Create many Project_team_members
     * const project_team_members = await prisma.project_team_members.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends project_team_membersCreateManyArgs>(args?: SelectSubset<T, project_team_membersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Project_team_members and returns the data saved in the database.
     * @param {project_team_membersCreateManyAndReturnArgs} args - Arguments to create many Project_team_members.
     * @example
     * // Create many Project_team_members
     * const project_team_members = await prisma.project_team_members.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Project_team_members and only return the `id`
     * const project_team_membersWithIdOnly = await prisma.project_team_members.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends project_team_membersCreateManyAndReturnArgs>(args?: SelectSubset<T, project_team_membersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project_team_members.
     * @param {project_team_membersDeleteArgs} args - Arguments to delete one Project_team_members.
     * @example
     * // Delete one Project_team_members
     * const Project_team_members = await prisma.project_team_members.delete({
     *   where: {
     *     // ... filter to delete one Project_team_members
     *   }
     * })
     * 
     */
    delete<T extends project_team_membersDeleteArgs>(args: SelectSubset<T, project_team_membersDeleteArgs<ExtArgs>>): Prisma__project_team_membersClient<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project_team_members.
     * @param {project_team_membersUpdateArgs} args - Arguments to update one Project_team_members.
     * @example
     * // Update one Project_team_members
     * const project_team_members = await prisma.project_team_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends project_team_membersUpdateArgs>(args: SelectSubset<T, project_team_membersUpdateArgs<ExtArgs>>): Prisma__project_team_membersClient<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Project_team_members.
     * @param {project_team_membersDeleteManyArgs} args - Arguments to filter Project_team_members to delete.
     * @example
     * // Delete a few Project_team_members
     * const { count } = await prisma.project_team_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends project_team_membersDeleteManyArgs>(args?: SelectSubset<T, project_team_membersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Project_team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_team_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Project_team_members
     * const project_team_members = await prisma.project_team_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends project_team_membersUpdateManyArgs>(args: SelectSubset<T, project_team_membersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Project_team_members and returns the data updated in the database.
     * @param {project_team_membersUpdateManyAndReturnArgs} args - Arguments to update many Project_team_members.
     * @example
     * // Update many Project_team_members
     * const project_team_members = await prisma.project_team_members.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Project_team_members and only return the `id`
     * const project_team_membersWithIdOnly = await prisma.project_team_members.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends project_team_membersUpdateManyAndReturnArgs>(args: SelectSubset<T, project_team_membersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project_team_members.
     * @param {project_team_membersUpsertArgs} args - Arguments to update or create a Project_team_members.
     * @example
     * // Update or create a Project_team_members
     * const project_team_members = await prisma.project_team_members.upsert({
     *   create: {
     *     // ... data to create a Project_team_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project_team_members we want to update
     *   }
     * })
     */
    upsert<T extends project_team_membersUpsertArgs>(args: SelectSubset<T, project_team_membersUpsertArgs<ExtArgs>>): Prisma__project_team_membersClient<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Project_team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_team_membersCountArgs} args - Arguments to filter Project_team_members to count.
     * @example
     * // Count the number of Project_team_members
     * const count = await prisma.project_team_members.count({
     *   where: {
     *     // ... the filter for the Project_team_members we want to count
     *   }
     * })
    **/
    count<T extends project_team_membersCountArgs>(
      args?: Subset<T, project_team_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Project_team_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project_team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Project_team_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Project_team_membersAggregateArgs>(args: Subset<T, Project_team_membersAggregateArgs>): Prisma.PrismaPromise<GetProject_team_membersAggregateType<T>>

    /**
     * Group by Project_team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_team_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends project_team_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: project_team_membersGroupByArgs['orderBy'] }
        : { orderBy?: project_team_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, project_team_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProject_team_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the project_team_members model
   */
  readonly fields: project_team_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for project_team_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__project_team_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends employeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeesDefaultArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project_teams<T extends project_teamsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, project_teamsDefaultArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role_levels<T extends role_levelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, role_levelsDefaultArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the project_team_members model
   */
  interface project_team_membersFieldRefs {
    readonly id: FieldRef<"project_team_members", 'Int'>
    readonly role_id: FieldRef<"project_team_members", 'Int'>
    readonly project_teams_id: FieldRef<"project_team_members", 'Int'>
    readonly job_description: FieldRef<"project_team_members", 'String'>
    readonly end_at: FieldRef<"project_team_members", 'DateTime'>
    readonly employee_id: FieldRef<"project_team_members", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * project_team_members findUnique
   */
  export type project_team_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * Filter, which project_team_members to fetch.
     */
    where: project_team_membersWhereUniqueInput
  }

  /**
   * project_team_members findUniqueOrThrow
   */
  export type project_team_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * Filter, which project_team_members to fetch.
     */
    where: project_team_membersWhereUniqueInput
  }

  /**
   * project_team_members findFirst
   */
  export type project_team_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * Filter, which project_team_members to fetch.
     */
    where?: project_team_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_team_members to fetch.
     */
    orderBy?: project_team_membersOrderByWithRelationInput | project_team_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_team_members.
     */
    cursor?: project_team_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_team_members.
     */
    distinct?: Project_team_membersScalarFieldEnum | Project_team_membersScalarFieldEnum[]
  }

  /**
   * project_team_members findFirstOrThrow
   */
  export type project_team_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * Filter, which project_team_members to fetch.
     */
    where?: project_team_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_team_members to fetch.
     */
    orderBy?: project_team_membersOrderByWithRelationInput | project_team_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_team_members.
     */
    cursor?: project_team_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_team_members.
     */
    distinct?: Project_team_membersScalarFieldEnum | Project_team_membersScalarFieldEnum[]
  }

  /**
   * project_team_members findMany
   */
  export type project_team_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * Filter, which project_team_members to fetch.
     */
    where?: project_team_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_team_members to fetch.
     */
    orderBy?: project_team_membersOrderByWithRelationInput | project_team_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing project_team_members.
     */
    cursor?: project_team_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_team_members.
     */
    skip?: number
    distinct?: Project_team_membersScalarFieldEnum | Project_team_membersScalarFieldEnum[]
  }

  /**
   * project_team_members create
   */
  export type project_team_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * The data needed to create a project_team_members.
     */
    data: XOR<project_team_membersCreateInput, project_team_membersUncheckedCreateInput>
  }

  /**
   * project_team_members createMany
   */
  export type project_team_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many project_team_members.
     */
    data: project_team_membersCreateManyInput | project_team_membersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project_team_members createManyAndReturn
   */
  export type project_team_membersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * The data used to create many project_team_members.
     */
    data: project_team_membersCreateManyInput | project_team_membersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * project_team_members update
   */
  export type project_team_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * The data needed to update a project_team_members.
     */
    data: XOR<project_team_membersUpdateInput, project_team_membersUncheckedUpdateInput>
    /**
     * Choose, which project_team_members to update.
     */
    where: project_team_membersWhereUniqueInput
  }

  /**
   * project_team_members updateMany
   */
  export type project_team_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update project_team_members.
     */
    data: XOR<project_team_membersUpdateManyMutationInput, project_team_membersUncheckedUpdateManyInput>
    /**
     * Filter which project_team_members to update
     */
    where?: project_team_membersWhereInput
    /**
     * Limit how many project_team_members to update.
     */
    limit?: number
  }

  /**
   * project_team_members updateManyAndReturn
   */
  export type project_team_membersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * The data used to update project_team_members.
     */
    data: XOR<project_team_membersUpdateManyMutationInput, project_team_membersUncheckedUpdateManyInput>
    /**
     * Filter which project_team_members to update
     */
    where?: project_team_membersWhereInput
    /**
     * Limit how many project_team_members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * project_team_members upsert
   */
  export type project_team_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * The filter to search for the project_team_members to update in case it exists.
     */
    where: project_team_membersWhereUniqueInput
    /**
     * In case the project_team_members found by the `where` argument doesn't exist, create a new project_team_members with this data.
     */
    create: XOR<project_team_membersCreateInput, project_team_membersUncheckedCreateInput>
    /**
     * In case the project_team_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<project_team_membersUpdateInput, project_team_membersUncheckedUpdateInput>
  }

  /**
   * project_team_members delete
   */
  export type project_team_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    /**
     * Filter which project_team_members to delete.
     */
    where: project_team_membersWhereUniqueInput
  }

  /**
   * project_team_members deleteMany
   */
  export type project_team_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_team_members to delete
     */
    where?: project_team_membersWhereInput
    /**
     * Limit how many project_team_members to delete.
     */
    limit?: number
  }

  /**
   * project_team_members without action
   */
  export type project_team_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
  }


  /**
   * Model project_teams
   */

  export type AggregateProject_teams = {
    _count: Project_teamsCountAggregateOutputType | null
    _avg: Project_teamsAvgAggregateOutputType | null
    _sum: Project_teamsSumAggregateOutputType | null
    _min: Project_teamsMinAggregateOutputType | null
    _max: Project_teamsMaxAggregateOutputType | null
  }

  export type Project_teamsAvgAggregateOutputType = {
    id: number | null
    manager_id: number | null
    auditor_id: number | null
    project_id: number | null
  }

  export type Project_teamsSumAggregateOutputType = {
    id: number | null
    manager_id: number | null
    auditor_id: number | null
    project_id: number | null
  }

  export type Project_teamsMinAggregateOutputType = {
    id: number | null
    project_teams_name: string | null
    project_teams_email: string | null
    manager_id: number | null
    auditor_id: number | null
    project_id: number | null
  }

  export type Project_teamsMaxAggregateOutputType = {
    id: number | null
    project_teams_name: string | null
    project_teams_email: string | null
    manager_id: number | null
    auditor_id: number | null
    project_id: number | null
  }

  export type Project_teamsCountAggregateOutputType = {
    id: number
    project_teams_name: number
    project_teams_email: number
    manager_id: number
    auditor_id: number
    project_id: number
    _all: number
  }


  export type Project_teamsAvgAggregateInputType = {
    id?: true
    manager_id?: true
    auditor_id?: true
    project_id?: true
  }

  export type Project_teamsSumAggregateInputType = {
    id?: true
    manager_id?: true
    auditor_id?: true
    project_id?: true
  }

  export type Project_teamsMinAggregateInputType = {
    id?: true
    project_teams_name?: true
    project_teams_email?: true
    manager_id?: true
    auditor_id?: true
    project_id?: true
  }

  export type Project_teamsMaxAggregateInputType = {
    id?: true
    project_teams_name?: true
    project_teams_email?: true
    manager_id?: true
    auditor_id?: true
    project_id?: true
  }

  export type Project_teamsCountAggregateInputType = {
    id?: true
    project_teams_name?: true
    project_teams_email?: true
    manager_id?: true
    auditor_id?: true
    project_id?: true
    _all?: true
  }

  export type Project_teamsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_teams to aggregate.
     */
    where?: project_teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_teams to fetch.
     */
    orderBy?: project_teamsOrderByWithRelationInput | project_teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: project_teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned project_teams
    **/
    _count?: true | Project_teamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Project_teamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Project_teamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Project_teamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Project_teamsMaxAggregateInputType
  }

  export type GetProject_teamsAggregateType<T extends Project_teamsAggregateArgs> = {
        [P in keyof T & keyof AggregateProject_teams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject_teams[P]>
      : GetScalarType<T[P], AggregateProject_teams[P]>
  }




  export type project_teamsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: project_teamsWhereInput
    orderBy?: project_teamsOrderByWithAggregationInput | project_teamsOrderByWithAggregationInput[]
    by: Project_teamsScalarFieldEnum[] | Project_teamsScalarFieldEnum
    having?: project_teamsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Project_teamsCountAggregateInputType | true
    _avg?: Project_teamsAvgAggregateInputType
    _sum?: Project_teamsSumAggregateInputType
    _min?: Project_teamsMinAggregateInputType
    _max?: Project_teamsMaxAggregateInputType
  }

  export type Project_teamsGroupByOutputType = {
    id: number
    project_teams_name: string
    project_teams_email: string
    manager_id: number
    auditor_id: number | null
    project_id: number
    _count: Project_teamsCountAggregateOutputType | null
    _avg: Project_teamsAvgAggregateOutputType | null
    _sum: Project_teamsSumAggregateOutputType | null
    _min: Project_teamsMinAggregateOutputType | null
    _max: Project_teamsMaxAggregateOutputType | null
  }

  type GetProject_teamsGroupByPayload<T extends project_teamsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Project_teamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Project_teamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Project_teamsGroupByOutputType[P]>
            : GetScalarType<T[P], Project_teamsGroupByOutputType[P]>
        }
      >
    >


  export type project_teamsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_teams_name?: boolean
    project_teams_email?: boolean
    manager_id?: boolean
    auditor_id?: boolean
    project_id?: boolean
    project_team_members?: boolean | project_teams$project_team_membersArgs<ExtArgs>
    employees_project_teams_auditor_idToemployees?: boolean | project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs>
    employees_project_teams_manager_idToemployees?: boolean | employeesDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
    _count?: boolean | Project_teamsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_teams"]>

  export type project_teamsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_teams_name?: boolean
    project_teams_email?: boolean
    manager_id?: boolean
    auditor_id?: boolean
    project_id?: boolean
    employees_project_teams_auditor_idToemployees?: boolean | project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs>
    employees_project_teams_manager_idToemployees?: boolean | employeesDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_teams"]>

  export type project_teamsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_teams_name?: boolean
    project_teams_email?: boolean
    manager_id?: boolean
    auditor_id?: boolean
    project_id?: boolean
    employees_project_teams_auditor_idToemployees?: boolean | project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs>
    employees_project_teams_manager_idToemployees?: boolean | employeesDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project_teams"]>

  export type project_teamsSelectScalar = {
    id?: boolean
    project_teams_name?: boolean
    project_teams_email?: boolean
    manager_id?: boolean
    auditor_id?: boolean
    project_id?: boolean
  }

  export type project_teamsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_teams_name" | "project_teams_email" | "manager_id" | "auditor_id" | "project_id", ExtArgs["result"]["project_teams"]>
  export type project_teamsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_team_members?: boolean | project_teams$project_team_membersArgs<ExtArgs>
    employees_project_teams_auditor_idToemployees?: boolean | project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs>
    employees_project_teams_manager_idToemployees?: boolean | employeesDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
    _count?: boolean | Project_teamsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type project_teamsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees_project_teams_auditor_idToemployees?: boolean | project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs>
    employees_project_teams_manager_idToemployees?: boolean | employeesDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }
  export type project_teamsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees_project_teams_auditor_idToemployees?: boolean | project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs>
    employees_project_teams_manager_idToemployees?: boolean | employeesDefaultArgs<ExtArgs>
    projects?: boolean | projectsDefaultArgs<ExtArgs>
  }

  export type $project_teamsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "project_teams"
    objects: {
      project_team_members: Prisma.$project_team_membersPayload<ExtArgs>[]
      employees_project_teams_auditor_idToemployees: Prisma.$employeesPayload<ExtArgs> | null
      employees_project_teams_manager_idToemployees: Prisma.$employeesPayload<ExtArgs>
      projects: Prisma.$projectsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      project_teams_name: string
      project_teams_email: string
      manager_id: number
      auditor_id: number | null
      project_id: number
    }, ExtArgs["result"]["project_teams"]>
    composites: {}
  }

  type project_teamsGetPayload<S extends boolean | null | undefined | project_teamsDefaultArgs> = $Result.GetResult<Prisma.$project_teamsPayload, S>

  type project_teamsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<project_teamsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Project_teamsCountAggregateInputType | true
    }

  export interface project_teamsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['project_teams'], meta: { name: 'project_teams' } }
    /**
     * Find zero or one Project_teams that matches the filter.
     * @param {project_teamsFindUniqueArgs} args - Arguments to find a Project_teams
     * @example
     * // Get one Project_teams
     * const project_teams = await prisma.project_teams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends project_teamsFindUniqueArgs>(args: SelectSubset<T, project_teamsFindUniqueArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project_teams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {project_teamsFindUniqueOrThrowArgs} args - Arguments to find a Project_teams
     * @example
     * // Get one Project_teams
     * const project_teams = await prisma.project_teams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends project_teamsFindUniqueOrThrowArgs>(args: SelectSubset<T, project_teamsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project_teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_teamsFindFirstArgs} args - Arguments to find a Project_teams
     * @example
     * // Get one Project_teams
     * const project_teams = await prisma.project_teams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends project_teamsFindFirstArgs>(args?: SelectSubset<T, project_teamsFindFirstArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project_teams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_teamsFindFirstOrThrowArgs} args - Arguments to find a Project_teams
     * @example
     * // Get one Project_teams
     * const project_teams = await prisma.project_teams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends project_teamsFindFirstOrThrowArgs>(args?: SelectSubset<T, project_teamsFindFirstOrThrowArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Project_teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_teamsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Project_teams
     * const project_teams = await prisma.project_teams.findMany()
     * 
     * // Get first 10 Project_teams
     * const project_teams = await prisma.project_teams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const project_teamsWithIdOnly = await prisma.project_teams.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends project_teamsFindManyArgs>(args?: SelectSubset<T, project_teamsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project_teams.
     * @param {project_teamsCreateArgs} args - Arguments to create a Project_teams.
     * @example
     * // Create one Project_teams
     * const Project_teams = await prisma.project_teams.create({
     *   data: {
     *     // ... data to create a Project_teams
     *   }
     * })
     * 
     */
    create<T extends project_teamsCreateArgs>(args: SelectSubset<T, project_teamsCreateArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Project_teams.
     * @param {project_teamsCreateManyArgs} args - Arguments to create many Project_teams.
     * @example
     * // Create many Project_teams
     * const project_teams = await prisma.project_teams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends project_teamsCreateManyArgs>(args?: SelectSubset<T, project_teamsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Project_teams and returns the data saved in the database.
     * @param {project_teamsCreateManyAndReturnArgs} args - Arguments to create many Project_teams.
     * @example
     * // Create many Project_teams
     * const project_teams = await prisma.project_teams.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Project_teams and only return the `id`
     * const project_teamsWithIdOnly = await prisma.project_teams.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends project_teamsCreateManyAndReturnArgs>(args?: SelectSubset<T, project_teamsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project_teams.
     * @param {project_teamsDeleteArgs} args - Arguments to delete one Project_teams.
     * @example
     * // Delete one Project_teams
     * const Project_teams = await prisma.project_teams.delete({
     *   where: {
     *     // ... filter to delete one Project_teams
     *   }
     * })
     * 
     */
    delete<T extends project_teamsDeleteArgs>(args: SelectSubset<T, project_teamsDeleteArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project_teams.
     * @param {project_teamsUpdateArgs} args - Arguments to update one Project_teams.
     * @example
     * // Update one Project_teams
     * const project_teams = await prisma.project_teams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends project_teamsUpdateArgs>(args: SelectSubset<T, project_teamsUpdateArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Project_teams.
     * @param {project_teamsDeleteManyArgs} args - Arguments to filter Project_teams to delete.
     * @example
     * // Delete a few Project_teams
     * const { count } = await prisma.project_teams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends project_teamsDeleteManyArgs>(args?: SelectSubset<T, project_teamsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Project_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_teamsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Project_teams
     * const project_teams = await prisma.project_teams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends project_teamsUpdateManyArgs>(args: SelectSubset<T, project_teamsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Project_teams and returns the data updated in the database.
     * @param {project_teamsUpdateManyAndReturnArgs} args - Arguments to update many Project_teams.
     * @example
     * // Update many Project_teams
     * const project_teams = await prisma.project_teams.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Project_teams and only return the `id`
     * const project_teamsWithIdOnly = await prisma.project_teams.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends project_teamsUpdateManyAndReturnArgs>(args: SelectSubset<T, project_teamsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project_teams.
     * @param {project_teamsUpsertArgs} args - Arguments to update or create a Project_teams.
     * @example
     * // Update or create a Project_teams
     * const project_teams = await prisma.project_teams.upsert({
     *   create: {
     *     // ... data to create a Project_teams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project_teams we want to update
     *   }
     * })
     */
    upsert<T extends project_teamsUpsertArgs>(args: SelectSubset<T, project_teamsUpsertArgs<ExtArgs>>): Prisma__project_teamsClient<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Project_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_teamsCountArgs} args - Arguments to filter Project_teams to count.
     * @example
     * // Count the number of Project_teams
     * const count = await prisma.project_teams.count({
     *   where: {
     *     // ... the filter for the Project_teams we want to count
     *   }
     * })
    **/
    count<T extends project_teamsCountArgs>(
      args?: Subset<T, project_teamsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Project_teamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Project_teamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Project_teamsAggregateArgs>(args: Subset<T, Project_teamsAggregateArgs>): Prisma.PrismaPromise<GetProject_teamsAggregateType<T>>

    /**
     * Group by Project_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {project_teamsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends project_teamsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: project_teamsGroupByArgs['orderBy'] }
        : { orderBy?: project_teamsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, project_teamsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProject_teamsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the project_teams model
   */
  readonly fields: project_teamsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for project_teams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__project_teamsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project_team_members<T extends project_teams$project_team_membersArgs<ExtArgs> = {}>(args?: Subset<T, project_teams$project_team_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees_project_teams_auditor_idToemployees<T extends project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs> = {}>(args?: Subset<T, project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employees_project_teams_manager_idToemployees<T extends employeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeesDefaultArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends projectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projectsDefaultArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the project_teams model
   */
  interface project_teamsFieldRefs {
    readonly id: FieldRef<"project_teams", 'Int'>
    readonly project_teams_name: FieldRef<"project_teams", 'String'>
    readonly project_teams_email: FieldRef<"project_teams", 'String'>
    readonly manager_id: FieldRef<"project_teams", 'Int'>
    readonly auditor_id: FieldRef<"project_teams", 'Int'>
    readonly project_id: FieldRef<"project_teams", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * project_teams findUnique
   */
  export type project_teamsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * Filter, which project_teams to fetch.
     */
    where: project_teamsWhereUniqueInput
  }

  /**
   * project_teams findUniqueOrThrow
   */
  export type project_teamsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * Filter, which project_teams to fetch.
     */
    where: project_teamsWhereUniqueInput
  }

  /**
   * project_teams findFirst
   */
  export type project_teamsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * Filter, which project_teams to fetch.
     */
    where?: project_teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_teams to fetch.
     */
    orderBy?: project_teamsOrderByWithRelationInput | project_teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_teams.
     */
    cursor?: project_teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_teams.
     */
    distinct?: Project_teamsScalarFieldEnum | Project_teamsScalarFieldEnum[]
  }

  /**
   * project_teams findFirstOrThrow
   */
  export type project_teamsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * Filter, which project_teams to fetch.
     */
    where?: project_teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_teams to fetch.
     */
    orderBy?: project_teamsOrderByWithRelationInput | project_teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_teams.
     */
    cursor?: project_teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of project_teams.
     */
    distinct?: Project_teamsScalarFieldEnum | Project_teamsScalarFieldEnum[]
  }

  /**
   * project_teams findMany
   */
  export type project_teamsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * Filter, which project_teams to fetch.
     */
    where?: project_teamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of project_teams to fetch.
     */
    orderBy?: project_teamsOrderByWithRelationInput | project_teamsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing project_teams.
     */
    cursor?: project_teamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_teams.
     */
    skip?: number
    distinct?: Project_teamsScalarFieldEnum | Project_teamsScalarFieldEnum[]
  }

  /**
   * project_teams create
   */
  export type project_teamsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * The data needed to create a project_teams.
     */
    data: XOR<project_teamsCreateInput, project_teamsUncheckedCreateInput>
  }

  /**
   * project_teams createMany
   */
  export type project_teamsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many project_teams.
     */
    data: project_teamsCreateManyInput | project_teamsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * project_teams createManyAndReturn
   */
  export type project_teamsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * The data used to create many project_teams.
     */
    data: project_teamsCreateManyInput | project_teamsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * project_teams update
   */
  export type project_teamsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * The data needed to update a project_teams.
     */
    data: XOR<project_teamsUpdateInput, project_teamsUncheckedUpdateInput>
    /**
     * Choose, which project_teams to update.
     */
    where: project_teamsWhereUniqueInput
  }

  /**
   * project_teams updateMany
   */
  export type project_teamsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update project_teams.
     */
    data: XOR<project_teamsUpdateManyMutationInput, project_teamsUncheckedUpdateManyInput>
    /**
     * Filter which project_teams to update
     */
    where?: project_teamsWhereInput
    /**
     * Limit how many project_teams to update.
     */
    limit?: number
  }

  /**
   * project_teams updateManyAndReturn
   */
  export type project_teamsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * The data used to update project_teams.
     */
    data: XOR<project_teamsUpdateManyMutationInput, project_teamsUncheckedUpdateManyInput>
    /**
     * Filter which project_teams to update
     */
    where?: project_teamsWhereInput
    /**
     * Limit how many project_teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * project_teams upsert
   */
  export type project_teamsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * The filter to search for the project_teams to update in case it exists.
     */
    where: project_teamsWhereUniqueInput
    /**
     * In case the project_teams found by the `where` argument doesn't exist, create a new project_teams with this data.
     */
    create: XOR<project_teamsCreateInput, project_teamsUncheckedCreateInput>
    /**
     * In case the project_teams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<project_teamsUpdateInput, project_teamsUncheckedUpdateInput>
  }

  /**
   * project_teams delete
   */
  export type project_teamsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    /**
     * Filter which project_teams to delete.
     */
    where: project_teamsWhereUniqueInput
  }

  /**
   * project_teams deleteMany
   */
  export type project_teamsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which project_teams to delete
     */
    where?: project_teamsWhereInput
    /**
     * Limit how many project_teams to delete.
     */
    limit?: number
  }

  /**
   * project_teams.project_team_members
   */
  export type project_teams$project_team_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    where?: project_team_membersWhereInput
    orderBy?: project_team_membersOrderByWithRelationInput | project_team_membersOrderByWithRelationInput[]
    cursor?: project_team_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Project_team_membersScalarFieldEnum | Project_team_membersScalarFieldEnum[]
  }

  /**
   * project_teams.employees_project_teams_auditor_idToemployees
   */
  export type project_teams$employees_project_teams_auditor_idToemployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    where?: employeesWhereInput
  }

  /**
   * project_teams without action
   */
  export type project_teamsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
  }


  /**
   * Model projects
   */

  export type AggregateProjects = {
    _count: ProjectsCountAggregateOutputType | null
    _avg: ProjectsAvgAggregateOutputType | null
    _sum: ProjectsSumAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  export type ProjectsAvgAggregateOutputType = {
    id: number | null
    client_id: number | null
    contract_value: Decimal | null
  }

  export type ProjectsSumAggregateOutputType = {
    id: number | null
    client_id: number | null
    contract_value: Decimal | null
  }

  export type ProjectsMinAggregateOutputType = {
    id: number | null
    client_id: number | null
    project_name: string | null
    project_code: string | null
    project_type: $Enums.project_types | null
    contract_value: Decimal | null
    started_at: Date | null
    finished_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
  }

  export type ProjectsMaxAggregateOutputType = {
    id: number | null
    client_id: number | null
    project_name: string | null
    project_code: string | null
    project_type: $Enums.project_types | null
    contract_value: Decimal | null
    started_at: Date | null
    finished_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
  }

  export type ProjectsCountAggregateOutputType = {
    id: number
    client_id: number
    project_name: number
    project_code: number
    project_type: number
    contract_value: number
    started_at: number
    finished_at: number
    deleted_at: number
    is_deleted: number
    _all: number
  }


  export type ProjectsAvgAggregateInputType = {
    id?: true
    client_id?: true
    contract_value?: true
  }

  export type ProjectsSumAggregateInputType = {
    id?: true
    client_id?: true
    contract_value?: true
  }

  export type ProjectsMinAggregateInputType = {
    id?: true
    client_id?: true
    project_name?: true
    project_code?: true
    project_type?: true
    contract_value?: true
    started_at?: true
    finished_at?: true
    deleted_at?: true
    is_deleted?: true
  }

  export type ProjectsMaxAggregateInputType = {
    id?: true
    client_id?: true
    project_name?: true
    project_code?: true
    project_type?: true
    contract_value?: true
    started_at?: true
    finished_at?: true
    deleted_at?: true
    is_deleted?: true
  }

  export type ProjectsCountAggregateInputType = {
    id?: true
    client_id?: true
    project_name?: true
    project_code?: true
    project_type?: true
    contract_value?: true
    started_at?: true
    finished_at?: true
    deleted_at?: true
    is_deleted?: true
    _all?: true
  }

  export type ProjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projects to aggregate.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projects
    **/
    _count?: true | ProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectsMaxAggregateInputType
  }

  export type GetProjectsAggregateType<T extends ProjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjects[P]>
      : GetScalarType<T[P], AggregateProjects[P]>
  }




  export type projectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectsWhereInput
    orderBy?: projectsOrderByWithAggregationInput | projectsOrderByWithAggregationInput[]
    by: ProjectsScalarFieldEnum[] | ProjectsScalarFieldEnum
    having?: projectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectsCountAggregateInputType | true
    _avg?: ProjectsAvgAggregateInputType
    _sum?: ProjectsSumAggregateInputType
    _min?: ProjectsMinAggregateInputType
    _max?: ProjectsMaxAggregateInputType
  }

  export type ProjectsGroupByOutputType = {
    id: number
    client_id: number
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value: Decimal | null
    started_at: Date | null
    finished_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
    _count: ProjectsCountAggregateOutputType | null
    _avg: ProjectsAvgAggregateOutputType | null
    _sum: ProjectsSumAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  type GetProjectsGroupByPayload<T extends projectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
        }
      >
    >


  export type projectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    project_name?: boolean
    project_code?: boolean
    project_type?: boolean
    contract_value?: boolean
    started_at?: boolean
    finished_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    client_pics?: boolean | projects$client_picsArgs<ExtArgs>
    documents?: boolean | projects$documentsArgs<ExtArgs>
    project_teams?: boolean | projects$project_teamsArgs<ExtArgs>
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    _count?: boolean | ProjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>

  export type projectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    project_name?: boolean
    project_code?: boolean
    project_type?: boolean
    contract_value?: boolean
    started_at?: boolean
    finished_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    clients?: boolean | clientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>

  export type projectsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    project_name?: boolean
    project_code?: boolean
    project_type?: boolean
    contract_value?: boolean
    started_at?: boolean
    finished_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    clients?: boolean | clientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>

  export type projectsSelectScalar = {
    id?: boolean
    client_id?: boolean
    project_name?: boolean
    project_code?: boolean
    project_type?: boolean
    contract_value?: boolean
    started_at?: boolean
    finished_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
  }

  export type projectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "project_name" | "project_code" | "project_type" | "contract_value" | "started_at" | "finished_at" | "deleted_at" | "is_deleted", ExtArgs["result"]["projects"]>
  export type projectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client_pics?: boolean | projects$client_picsArgs<ExtArgs>
    documents?: boolean | projects$documentsArgs<ExtArgs>
    project_teams?: boolean | projects$project_teamsArgs<ExtArgs>
    clients?: boolean | clientsDefaultArgs<ExtArgs>
    _count?: boolean | ProjectsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type projectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | clientsDefaultArgs<ExtArgs>
  }
  export type projectsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | clientsDefaultArgs<ExtArgs>
  }

  export type $projectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projects"
    objects: {
      client_pics: Prisma.$client_picsPayload<ExtArgs>[]
      documents: Prisma.$documentsPayload<ExtArgs>[]
      project_teams: Prisma.$project_teamsPayload<ExtArgs>[]
      clients: Prisma.$clientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      client_id: number
      project_name: string
      project_code: string
      project_type: $Enums.project_types
      contract_value: Prisma.Decimal | null
      started_at: Date | null
      finished_at: Date | null
      deleted_at: Date | null
      is_deleted: boolean | null
    }, ExtArgs["result"]["projects"]>
    composites: {}
  }

  type projectsGetPayload<S extends boolean | null | undefined | projectsDefaultArgs> = $Result.GetResult<Prisma.$projectsPayload, S>

  type projectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectsCountAggregateInputType | true
    }

  export interface projectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projects'], meta: { name: 'projects' } }
    /**
     * Find zero or one Projects that matches the filter.
     * @param {projectsFindUniqueArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectsFindUniqueArgs>(args: SelectSubset<T, projectsFindUniqueArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Projects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projectsFindUniqueOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectsFindUniqueOrThrowArgs>(args: SelectSubset<T, projectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindFirstArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectsFindFirstArgs>(args?: SelectSubset<T, projectsFindFirstArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindFirstOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectsFindFirstOrThrowArgs>(args?: SelectSubset<T, projectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.projects.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.projects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectsWithIdOnly = await prisma.projects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projectsFindManyArgs>(args?: SelectSubset<T, projectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Projects.
     * @param {projectsCreateArgs} args - Arguments to create a Projects.
     * @example
     * // Create one Projects
     * const Projects = await prisma.projects.create({
     *   data: {
     *     // ... data to create a Projects
     *   }
     * })
     * 
     */
    create<T extends projectsCreateArgs>(args: SelectSubset<T, projectsCreateArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {projectsCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const projects = await prisma.projects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectsCreateManyArgs>(args?: SelectSubset<T, projectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {projectsCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const projects = await prisma.projects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectsWithIdOnly = await prisma.projects.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projectsCreateManyAndReturnArgs>(args?: SelectSubset<T, projectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Projects.
     * @param {projectsDeleteArgs} args - Arguments to delete one Projects.
     * @example
     * // Delete one Projects
     * const Projects = await prisma.projects.delete({
     *   where: {
     *     // ... filter to delete one Projects
     *   }
     * })
     * 
     */
    delete<T extends projectsDeleteArgs>(args: SelectSubset<T, projectsDeleteArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Projects.
     * @param {projectsUpdateArgs} args - Arguments to update one Projects.
     * @example
     * // Update one Projects
     * const projects = await prisma.projects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectsUpdateArgs>(args: SelectSubset<T, projectsUpdateArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {projectsDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.projects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectsDeleteManyArgs>(args?: SelectSubset<T, projectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectsUpdateManyArgs>(args: SelectSubset<T, projectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {projectsUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectsWithIdOnly = await prisma.projects.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projectsUpdateManyAndReturnArgs>(args: SelectSubset<T, projectsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Projects.
     * @param {projectsUpsertArgs} args - Arguments to update or create a Projects.
     * @example
     * // Update or create a Projects
     * const projects = await prisma.projects.upsert({
     *   create: {
     *     // ... data to create a Projects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projects we want to update
     *   }
     * })
     */
    upsert<T extends projectsUpsertArgs>(args: SelectSubset<T, projectsUpsertArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.projects.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends projectsCountArgs>(
      args?: Subset<T, projectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectsAggregateArgs>(args: Subset<T, ProjectsAggregateArgs>): Prisma.PrismaPromise<GetProjectsAggregateType<T>>

    /**
     * Group by Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectsGroupByArgs['orderBy'] }
        : { orderBy?: projectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projects model
   */
  readonly fields: projectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client_pics<T extends projects$client_picsArgs<ExtArgs> = {}>(args?: Subset<T, projects$client_picsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$client_picsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends projects$documentsArgs<ExtArgs> = {}>(args?: Subset<T, projects$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$documentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project_teams<T extends projects$project_teamsArgs<ExtArgs> = {}>(args?: Subset<T, projects$project_teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_teamsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clients<T extends clientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientsDefaultArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projects model
   */
  interface projectsFieldRefs {
    readonly id: FieldRef<"projects", 'Int'>
    readonly client_id: FieldRef<"projects", 'Int'>
    readonly project_name: FieldRef<"projects", 'String'>
    readonly project_code: FieldRef<"projects", 'String'>
    readonly project_type: FieldRef<"projects", 'project_types'>
    readonly contract_value: FieldRef<"projects", 'Decimal'>
    readonly started_at: FieldRef<"projects", 'DateTime'>
    readonly finished_at: FieldRef<"projects", 'DateTime'>
    readonly deleted_at: FieldRef<"projects", 'DateTime'>
    readonly is_deleted: FieldRef<"projects", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * projects findUnique
   */
  export type projectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects findUniqueOrThrow
   */
  export type projectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects findFirst
   */
  export type projectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects findFirstOrThrow
   */
  export type projectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects findMany
   */
  export type projectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects create
   */
  export type projectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * The data needed to create a projects.
     */
    data: XOR<projectsCreateInput, projectsUncheckedCreateInput>
  }

  /**
   * projects createMany
   */
  export type projectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projects.
     */
    data: projectsCreateManyInput | projectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projects createManyAndReturn
   */
  export type projectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * The data used to create many projects.
     */
    data: projectsCreateManyInput | projectsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projects update
   */
  export type projectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * The data needed to update a projects.
     */
    data: XOR<projectsUpdateInput, projectsUncheckedUpdateInput>
    /**
     * Choose, which projects to update.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects updateMany
   */
  export type projectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projects.
     */
    data: XOR<projectsUpdateManyMutationInput, projectsUncheckedUpdateManyInput>
    /**
     * Filter which projects to update
     */
    where?: projectsWhereInput
    /**
     * Limit how many projects to update.
     */
    limit?: number
  }

  /**
   * projects updateManyAndReturn
   */
  export type projectsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * The data used to update projects.
     */
    data: XOR<projectsUpdateManyMutationInput, projectsUncheckedUpdateManyInput>
    /**
     * Filter which projects to update
     */
    where?: projectsWhereInput
    /**
     * Limit how many projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projects upsert
   */
  export type projectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * The filter to search for the projects to update in case it exists.
     */
    where: projectsWhereUniqueInput
    /**
     * In case the projects found by the `where` argument doesn't exist, create a new projects with this data.
     */
    create: XOR<projectsCreateInput, projectsUncheckedCreateInput>
    /**
     * In case the projects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectsUpdateInput, projectsUncheckedUpdateInput>
  }

  /**
   * projects delete
   */
  export type projectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter which projects to delete.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects deleteMany
   */
  export type projectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projects to delete
     */
    where?: projectsWhereInput
    /**
     * Limit how many projects to delete.
     */
    limit?: number
  }

  /**
   * projects.client_pics
   */
  export type projects$client_picsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the client_pics
     */
    select?: client_picsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the client_pics
     */
    omit?: client_picsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: client_picsInclude<ExtArgs> | null
    where?: client_picsWhereInput
    orderBy?: client_picsOrderByWithRelationInput | client_picsOrderByWithRelationInput[]
    cursor?: client_picsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Client_picsScalarFieldEnum | Client_picsScalarFieldEnum[]
  }

  /**
   * projects.documents
   */
  export type projects$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the documents
     */
    select?: documentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the documents
     */
    omit?: documentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: documentsInclude<ExtArgs> | null
    where?: documentsWhereInput
    orderBy?: documentsOrderByWithRelationInput | documentsOrderByWithRelationInput[]
    cursor?: documentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentsScalarFieldEnum | DocumentsScalarFieldEnum[]
  }

  /**
   * projects.project_teams
   */
  export type projects$project_teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_teams
     */
    select?: project_teamsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_teams
     */
    omit?: project_teamsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_teamsInclude<ExtArgs> | null
    where?: project_teamsWhereInput
    orderBy?: project_teamsOrderByWithRelationInput | project_teamsOrderByWithRelationInput[]
    cursor?: project_teamsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Project_teamsScalarFieldEnum | Project_teamsScalarFieldEnum[]
  }

  /**
   * projects without action
   */
  export type projectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
  }


  /**
   * Model role_levels
   */

  export type AggregateRole_levels = {
    _count: Role_levelsCountAggregateOutputType | null
    _avg: Role_levelsAvgAggregateOutputType | null
    _sum: Role_levelsSumAggregateOutputType | null
    _min: Role_levelsMinAggregateOutputType | null
    _max: Role_levelsMaxAggregateOutputType | null
  }

  export type Role_levelsAvgAggregateOutputType = {
    id: number | null
    role_level: number | null
    role_price: Decimal | null
  }

  export type Role_levelsSumAggregateOutputType = {
    id: number | null
    role_level: number | null
    role_price: Decimal | null
  }

  export type Role_levelsMinAggregateOutputType = {
    id: number | null
    role_name: string | null
    role_level: number | null
    role_price: Decimal | null
    is_default: boolean | null
  }

  export type Role_levelsMaxAggregateOutputType = {
    id: number | null
    role_name: string | null
    role_level: number | null
    role_price: Decimal | null
    is_default: boolean | null
  }

  export type Role_levelsCountAggregateOutputType = {
    id: number
    role_name: number
    role_level: number
    role_price: number
    is_default: number
    _all: number
  }


  export type Role_levelsAvgAggregateInputType = {
    id?: true
    role_level?: true
    role_price?: true
  }

  export type Role_levelsSumAggregateInputType = {
    id?: true
    role_level?: true
    role_price?: true
  }

  export type Role_levelsMinAggregateInputType = {
    id?: true
    role_name?: true
    role_level?: true
    role_price?: true
    is_default?: true
  }

  export type Role_levelsMaxAggregateInputType = {
    id?: true
    role_name?: true
    role_level?: true
    role_price?: true
    is_default?: true
  }

  export type Role_levelsCountAggregateInputType = {
    id?: true
    role_name?: true
    role_level?: true
    role_price?: true
    is_default?: true
    _all?: true
  }

  export type Role_levelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_levels to aggregate.
     */
    where?: role_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_levels to fetch.
     */
    orderBy?: role_levelsOrderByWithRelationInput | role_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: role_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned role_levels
    **/
    _count?: true | Role_levelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Role_levelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Role_levelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Role_levelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Role_levelsMaxAggregateInputType
  }

  export type GetRole_levelsAggregateType<T extends Role_levelsAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_levels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole_levels[P]>
      : GetScalarType<T[P], AggregateRole_levels[P]>
  }




  export type role_levelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_levelsWhereInput
    orderBy?: role_levelsOrderByWithAggregationInput | role_levelsOrderByWithAggregationInput[]
    by: Role_levelsScalarFieldEnum[] | Role_levelsScalarFieldEnum
    having?: role_levelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Role_levelsCountAggregateInputType | true
    _avg?: Role_levelsAvgAggregateInputType
    _sum?: Role_levelsSumAggregateInputType
    _min?: Role_levelsMinAggregateInputType
    _max?: Role_levelsMaxAggregateInputType
  }

  export type Role_levelsGroupByOutputType = {
    id: number
    role_name: string | null
    role_level: number | null
    role_price: Decimal | null
    is_default: boolean | null
    _count: Role_levelsCountAggregateOutputType | null
    _avg: Role_levelsAvgAggregateOutputType | null
    _sum: Role_levelsSumAggregateOutputType | null
    _min: Role_levelsMinAggregateOutputType | null
    _max: Role_levelsMaxAggregateOutputType | null
  }

  type GetRole_levelsGroupByPayload<T extends role_levelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Role_levelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Role_levelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Role_levelsGroupByOutputType[P]>
            : GetScalarType<T[P], Role_levelsGroupByOutputType[P]>
        }
      >
    >


  export type role_levelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
    role_level?: boolean
    role_price?: boolean
    is_default?: boolean
    project_team_members?: boolean | role_levels$project_team_membersArgs<ExtArgs>
    _count?: boolean | Role_levelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_levels"]>

  export type role_levelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
    role_level?: boolean
    role_price?: boolean
    is_default?: boolean
  }, ExtArgs["result"]["role_levels"]>

  export type role_levelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
    role_level?: boolean
    role_price?: boolean
    is_default?: boolean
  }, ExtArgs["result"]["role_levels"]>

  export type role_levelsSelectScalar = {
    id?: boolean
    role_name?: boolean
    role_level?: boolean
    role_price?: boolean
    is_default?: boolean
  }

  export type role_levelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role_name" | "role_level" | "role_price" | "is_default", ExtArgs["result"]["role_levels"]>
  export type role_levelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project_team_members?: boolean | role_levels$project_team_membersArgs<ExtArgs>
    _count?: boolean | Role_levelsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type role_levelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type role_levelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $role_levelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role_levels"
    objects: {
      project_team_members: Prisma.$project_team_membersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role_name: string | null
      role_level: number | null
      role_price: Prisma.Decimal | null
      is_default: boolean | null
    }, ExtArgs["result"]["role_levels"]>
    composites: {}
  }

  type role_levelsGetPayload<S extends boolean | null | undefined | role_levelsDefaultArgs> = $Result.GetResult<Prisma.$role_levelsPayload, S>

  type role_levelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<role_levelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Role_levelsCountAggregateInputType | true
    }

  export interface role_levelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role_levels'], meta: { name: 'role_levels' } }
    /**
     * Find zero or one Role_levels that matches the filter.
     * @param {role_levelsFindUniqueArgs} args - Arguments to find a Role_levels
     * @example
     * // Get one Role_levels
     * const role_levels = await prisma.role_levels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends role_levelsFindUniqueArgs>(args: SelectSubset<T, role_levelsFindUniqueArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role_levels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {role_levelsFindUniqueOrThrowArgs} args - Arguments to find a Role_levels
     * @example
     * // Get one Role_levels
     * const role_levels = await prisma.role_levels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends role_levelsFindUniqueOrThrowArgs>(args: SelectSubset<T, role_levelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_levelsFindFirstArgs} args - Arguments to find a Role_levels
     * @example
     * // Get one Role_levels
     * const role_levels = await prisma.role_levels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends role_levelsFindFirstArgs>(args?: SelectSubset<T, role_levelsFindFirstArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_levels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_levelsFindFirstOrThrowArgs} args - Arguments to find a Role_levels
     * @example
     * // Get one Role_levels
     * const role_levels = await prisma.role_levels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends role_levelsFindFirstOrThrowArgs>(args?: SelectSubset<T, role_levelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Role_levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_levelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Role_levels
     * const role_levels = await prisma.role_levels.findMany()
     * 
     * // Get first 10 Role_levels
     * const role_levels = await prisma.role_levels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const role_levelsWithIdOnly = await prisma.role_levels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends role_levelsFindManyArgs>(args?: SelectSubset<T, role_levelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role_levels.
     * @param {role_levelsCreateArgs} args - Arguments to create a Role_levels.
     * @example
     * // Create one Role_levels
     * const Role_levels = await prisma.role_levels.create({
     *   data: {
     *     // ... data to create a Role_levels
     *   }
     * })
     * 
     */
    create<T extends role_levelsCreateArgs>(args: SelectSubset<T, role_levelsCreateArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Role_levels.
     * @param {role_levelsCreateManyArgs} args - Arguments to create many Role_levels.
     * @example
     * // Create many Role_levels
     * const role_levels = await prisma.role_levels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends role_levelsCreateManyArgs>(args?: SelectSubset<T, role_levelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Role_levels and returns the data saved in the database.
     * @param {role_levelsCreateManyAndReturnArgs} args - Arguments to create many Role_levels.
     * @example
     * // Create many Role_levels
     * const role_levels = await prisma.role_levels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Role_levels and only return the `id`
     * const role_levelsWithIdOnly = await prisma.role_levels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends role_levelsCreateManyAndReturnArgs>(args?: SelectSubset<T, role_levelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role_levels.
     * @param {role_levelsDeleteArgs} args - Arguments to delete one Role_levels.
     * @example
     * // Delete one Role_levels
     * const Role_levels = await prisma.role_levels.delete({
     *   where: {
     *     // ... filter to delete one Role_levels
     *   }
     * })
     * 
     */
    delete<T extends role_levelsDeleteArgs>(args: SelectSubset<T, role_levelsDeleteArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role_levels.
     * @param {role_levelsUpdateArgs} args - Arguments to update one Role_levels.
     * @example
     * // Update one Role_levels
     * const role_levels = await prisma.role_levels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends role_levelsUpdateArgs>(args: SelectSubset<T, role_levelsUpdateArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Role_levels.
     * @param {role_levelsDeleteManyArgs} args - Arguments to filter Role_levels to delete.
     * @example
     * // Delete a few Role_levels
     * const { count } = await prisma.role_levels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends role_levelsDeleteManyArgs>(args?: SelectSubset<T, role_levelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_levelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Role_levels
     * const role_levels = await prisma.role_levels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends role_levelsUpdateManyArgs>(args: SelectSubset<T, role_levelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_levels and returns the data updated in the database.
     * @param {role_levelsUpdateManyAndReturnArgs} args - Arguments to update many Role_levels.
     * @example
     * // Update many Role_levels
     * const role_levels = await prisma.role_levels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Role_levels and only return the `id`
     * const role_levelsWithIdOnly = await prisma.role_levels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends role_levelsUpdateManyAndReturnArgs>(args: SelectSubset<T, role_levelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role_levels.
     * @param {role_levelsUpsertArgs} args - Arguments to update or create a Role_levels.
     * @example
     * // Update or create a Role_levels
     * const role_levels = await prisma.role_levels.upsert({
     *   create: {
     *     // ... data to create a Role_levels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role_levels we want to update
     *   }
     * })
     */
    upsert<T extends role_levelsUpsertArgs>(args: SelectSubset<T, role_levelsUpsertArgs<ExtArgs>>): Prisma__role_levelsClient<$Result.GetResult<Prisma.$role_levelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Role_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_levelsCountArgs} args - Arguments to filter Role_levels to count.
     * @example
     * // Count the number of Role_levels
     * const count = await prisma.role_levels.count({
     *   where: {
     *     // ... the filter for the Role_levels we want to count
     *   }
     * })
    **/
    count<T extends role_levelsCountArgs>(
      args?: Subset<T, role_levelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Role_levelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_levelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Role_levelsAggregateArgs>(args: Subset<T, Role_levelsAggregateArgs>): Prisma.PrismaPromise<GetRole_levelsAggregateType<T>>

    /**
     * Group by Role_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_levelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends role_levelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: role_levelsGroupByArgs['orderBy'] }
        : { orderBy?: role_levelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, role_levelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRole_levelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role_levels model
   */
  readonly fields: role_levelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role_levels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__role_levelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project_team_members<T extends role_levels$project_team_membersArgs<ExtArgs> = {}>(args?: Subset<T, role_levels$project_team_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$project_team_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role_levels model
   */
  interface role_levelsFieldRefs {
    readonly id: FieldRef<"role_levels", 'Int'>
    readonly role_name: FieldRef<"role_levels", 'String'>
    readonly role_level: FieldRef<"role_levels", 'Int'>
    readonly role_price: FieldRef<"role_levels", 'Decimal'>
    readonly is_default: FieldRef<"role_levels", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * role_levels findUnique
   */
  export type role_levelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * Filter, which role_levels to fetch.
     */
    where: role_levelsWhereUniqueInput
  }

  /**
   * role_levels findUniqueOrThrow
   */
  export type role_levelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * Filter, which role_levels to fetch.
     */
    where: role_levelsWhereUniqueInput
  }

  /**
   * role_levels findFirst
   */
  export type role_levelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * Filter, which role_levels to fetch.
     */
    where?: role_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_levels to fetch.
     */
    orderBy?: role_levelsOrderByWithRelationInput | role_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_levels.
     */
    cursor?: role_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_levels.
     */
    distinct?: Role_levelsScalarFieldEnum | Role_levelsScalarFieldEnum[]
  }

  /**
   * role_levels findFirstOrThrow
   */
  export type role_levelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * Filter, which role_levels to fetch.
     */
    where?: role_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_levels to fetch.
     */
    orderBy?: role_levelsOrderByWithRelationInput | role_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_levels.
     */
    cursor?: role_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_levels.
     */
    distinct?: Role_levelsScalarFieldEnum | Role_levelsScalarFieldEnum[]
  }

  /**
   * role_levels findMany
   */
  export type role_levelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * Filter, which role_levels to fetch.
     */
    where?: role_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_levels to fetch.
     */
    orderBy?: role_levelsOrderByWithRelationInput | role_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing role_levels.
     */
    cursor?: role_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_levels.
     */
    skip?: number
    distinct?: Role_levelsScalarFieldEnum | Role_levelsScalarFieldEnum[]
  }

  /**
   * role_levels create
   */
  export type role_levelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * The data needed to create a role_levels.
     */
    data?: XOR<role_levelsCreateInput, role_levelsUncheckedCreateInput>
  }

  /**
   * role_levels createMany
   */
  export type role_levelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many role_levels.
     */
    data: role_levelsCreateManyInput | role_levelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role_levels createManyAndReturn
   */
  export type role_levelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * The data used to create many role_levels.
     */
    data: role_levelsCreateManyInput | role_levelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role_levels update
   */
  export type role_levelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * The data needed to update a role_levels.
     */
    data: XOR<role_levelsUpdateInput, role_levelsUncheckedUpdateInput>
    /**
     * Choose, which role_levels to update.
     */
    where: role_levelsWhereUniqueInput
  }

  /**
   * role_levels updateMany
   */
  export type role_levelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update role_levels.
     */
    data: XOR<role_levelsUpdateManyMutationInput, role_levelsUncheckedUpdateManyInput>
    /**
     * Filter which role_levels to update
     */
    where?: role_levelsWhereInput
    /**
     * Limit how many role_levels to update.
     */
    limit?: number
  }

  /**
   * role_levels updateManyAndReturn
   */
  export type role_levelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * The data used to update role_levels.
     */
    data: XOR<role_levelsUpdateManyMutationInput, role_levelsUncheckedUpdateManyInput>
    /**
     * Filter which role_levels to update
     */
    where?: role_levelsWhereInput
    /**
     * Limit how many role_levels to update.
     */
    limit?: number
  }

  /**
   * role_levels upsert
   */
  export type role_levelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * The filter to search for the role_levels to update in case it exists.
     */
    where: role_levelsWhereUniqueInput
    /**
     * In case the role_levels found by the `where` argument doesn't exist, create a new role_levels with this data.
     */
    create: XOR<role_levelsCreateInput, role_levelsUncheckedCreateInput>
    /**
     * In case the role_levels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<role_levelsUpdateInput, role_levelsUncheckedUpdateInput>
  }

  /**
   * role_levels delete
   */
  export type role_levelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
    /**
     * Filter which role_levels to delete.
     */
    where: role_levelsWhereUniqueInput
  }

  /**
   * role_levels deleteMany
   */
  export type role_levelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_levels to delete
     */
    where?: role_levelsWhereInput
    /**
     * Limit how many role_levels to delete.
     */
    limit?: number
  }

  /**
   * role_levels.project_team_members
   */
  export type role_levels$project_team_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the project_team_members
     */
    select?: project_team_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the project_team_members
     */
    omit?: project_team_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: project_team_membersInclude<ExtArgs> | null
    where?: project_team_membersWhereInput
    orderBy?: project_team_membersOrderByWithRelationInput | project_team_membersOrderByWithRelationInput[]
    cursor?: project_team_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Project_team_membersScalarFieldEnum | Project_team_membersScalarFieldEnum[]
  }

  /**
   * role_levels without action
   */
  export type role_levelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_levels
     */
    select?: role_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_levels
     */
    omit?: role_levelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_levelsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Client_picsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    title: 'title',
    project_id: 'project_id',
    client_id: 'client_id'
  };

  export type Client_picsScalarFieldEnum = (typeof Client_picsScalarFieldEnum)[keyof typeof Client_picsScalarFieldEnum]


  export const ClientsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    masked_description: 'masked_description',
    address: 'address',
    phone: 'phone',
    npwp: 'npwp',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClientsScalarFieldEnum = (typeof ClientsScalarFieldEnum)[keyof typeof ClientsScalarFieldEnum]


  export const DocumentsScalarFieldEnum: {
    id: 'id',
    document_types: 'document_types',
    number: 'number',
    date_created: 'date_created',
    date_signed: 'date_signed',
    document_url: 'document_url',
    project_id: 'project_id',
    client_pic_id: 'client_pic_id',
    client_id: 'client_id'
  };

  export type DocumentsScalarFieldEnum = (typeof DocumentsScalarFieldEnum)[keyof typeof DocumentsScalarFieldEnum]


  export const EmployeesScalarFieldEnum: {
    id: 'id',
    nik: 'nik',
    nip: 'nip',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    position: 'position',
    status: 'status',
    password: 'password',
    refresh_token: 'refresh_token'
  };

  export type EmployeesScalarFieldEnum = (typeof EmployeesScalarFieldEnum)[keyof typeof EmployeesScalarFieldEnum]


  export const Project_team_membersScalarFieldEnum: {
    id: 'id',
    role_id: 'role_id',
    project_teams_id: 'project_teams_id',
    job_description: 'job_description',
    end_at: 'end_at',
    employee_id: 'employee_id'
  };

  export type Project_team_membersScalarFieldEnum = (typeof Project_team_membersScalarFieldEnum)[keyof typeof Project_team_membersScalarFieldEnum]


  export const Project_teamsScalarFieldEnum: {
    id: 'id',
    project_teams_name: 'project_teams_name',
    project_teams_email: 'project_teams_email',
    manager_id: 'manager_id',
    auditor_id: 'auditor_id',
    project_id: 'project_id'
  };

  export type Project_teamsScalarFieldEnum = (typeof Project_teamsScalarFieldEnum)[keyof typeof Project_teamsScalarFieldEnum]


  export const ProjectsScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    project_name: 'project_name',
    project_code: 'project_code',
    project_type: 'project_type',
    contract_value: 'contract_value',
    started_at: 'started_at',
    finished_at: 'finished_at',
    deleted_at: 'deleted_at',
    is_deleted: 'is_deleted'
  };

  export type ProjectsScalarFieldEnum = (typeof ProjectsScalarFieldEnum)[keyof typeof ProjectsScalarFieldEnum]


  export const Role_levelsScalarFieldEnum: {
    id: 'id',
    role_name: 'role_name',
    role_level: 'role_level',
    role_price: 'role_price',
    is_default: 'is_default'
  };

  export type Role_levelsScalarFieldEnum = (typeof Role_levelsScalarFieldEnum)[keyof typeof Role_levelsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'document_types'
   */
  export type Enumdocument_typesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'document_types'>
    


  /**
   * Reference to a field of type 'document_types[]'
   */
  export type ListEnumdocument_typesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'document_types[]'>
    


  /**
   * Reference to a field of type 'status_employees'
   */
  export type Enumstatus_employeesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'status_employees'>
    


  /**
   * Reference to a field of type 'status_employees[]'
   */
  export type ListEnumstatus_employeesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'status_employees[]'>
    


  /**
   * Reference to a field of type 'project_types'
   */
  export type Enumproject_typesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'project_types'>
    


  /**
   * Reference to a field of type 'project_types[]'
   */
  export type ListEnumproject_typesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'project_types[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type client_picsWhereInput = {
    AND?: client_picsWhereInput | client_picsWhereInput[]
    OR?: client_picsWhereInput[]
    NOT?: client_picsWhereInput | client_picsWhereInput[]
    id?: IntFilter<"client_pics"> | number
    name?: StringFilter<"client_pics"> | string
    email?: StringNullableFilter<"client_pics"> | string | null
    phone?: StringNullableFilter<"client_pics"> | string | null
    title?: StringNullableFilter<"client_pics"> | string | null
    project_id?: IntFilter<"client_pics"> | number
    client_id?: IntFilter<"client_pics"> | number
    clients?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, projectsWhereInput>
    documents?: DocumentsListRelationFilter
  }

  export type client_picsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    clients?: clientsOrderByWithRelationInput
    projects?: projectsOrderByWithRelationInput
    documents?: documentsOrderByRelationAggregateInput
  }

  export type client_picsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: client_picsWhereInput | client_picsWhereInput[]
    OR?: client_picsWhereInput[]
    NOT?: client_picsWhereInput | client_picsWhereInput[]
    name?: StringFilter<"client_pics"> | string
    email?: StringNullableFilter<"client_pics"> | string | null
    phone?: StringNullableFilter<"client_pics"> | string | null
    title?: StringNullableFilter<"client_pics"> | string | null
    project_id?: IntFilter<"client_pics"> | number
    client_id?: IntFilter<"client_pics"> | number
    clients?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, projectsWhereInput>
    documents?: DocumentsListRelationFilter
  }, "id">

  export type client_picsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    _count?: client_picsCountOrderByAggregateInput
    _avg?: client_picsAvgOrderByAggregateInput
    _max?: client_picsMaxOrderByAggregateInput
    _min?: client_picsMinOrderByAggregateInput
    _sum?: client_picsSumOrderByAggregateInput
  }

  export type client_picsScalarWhereWithAggregatesInput = {
    AND?: client_picsScalarWhereWithAggregatesInput | client_picsScalarWhereWithAggregatesInput[]
    OR?: client_picsScalarWhereWithAggregatesInput[]
    NOT?: client_picsScalarWhereWithAggregatesInput | client_picsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"client_pics"> | number
    name?: StringWithAggregatesFilter<"client_pics"> | string
    email?: StringNullableWithAggregatesFilter<"client_pics"> | string | null
    phone?: StringNullableWithAggregatesFilter<"client_pics"> | string | null
    title?: StringNullableWithAggregatesFilter<"client_pics"> | string | null
    project_id?: IntWithAggregatesFilter<"client_pics"> | number
    client_id?: IntWithAggregatesFilter<"client_pics"> | number
  }

  export type clientsWhereInput = {
    AND?: clientsWhereInput | clientsWhereInput[]
    OR?: clientsWhereInput[]
    NOT?: clientsWhereInput | clientsWhereInput[]
    id?: IntFilter<"clients"> | number
    name?: StringFilter<"clients"> | string
    masked_description?: StringNullableFilter<"clients"> | string | null
    address?: StringNullableFilter<"clients"> | string | null
    phone?: StringNullableFilter<"clients"> | string | null
    npwp?: StringNullableFilter<"clients"> | string | null
    created_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    client_pics?: Client_picsListRelationFilter
    documents?: DocumentsListRelationFilter
    projects?: ProjectsListRelationFilter
  }

  export type clientsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    masked_description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    npwp?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    client_pics?: client_picsOrderByRelationAggregateInput
    documents?: documentsOrderByRelationAggregateInput
    projects?: projectsOrderByRelationAggregateInput
  }

  export type clientsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: clientsWhereInput | clientsWhereInput[]
    OR?: clientsWhereInput[]
    NOT?: clientsWhereInput | clientsWhereInput[]
    name?: StringFilter<"clients"> | string
    masked_description?: StringNullableFilter<"clients"> | string | null
    address?: StringNullableFilter<"clients"> | string | null
    phone?: StringNullableFilter<"clients"> | string | null
    npwp?: StringNullableFilter<"clients"> | string | null
    created_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    client_pics?: Client_picsListRelationFilter
    documents?: DocumentsListRelationFilter
    projects?: ProjectsListRelationFilter
  }, "id">

  export type clientsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    masked_description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    npwp?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: clientsCountOrderByAggregateInput
    _avg?: clientsAvgOrderByAggregateInput
    _max?: clientsMaxOrderByAggregateInput
    _min?: clientsMinOrderByAggregateInput
    _sum?: clientsSumOrderByAggregateInput
  }

  export type clientsScalarWhereWithAggregatesInput = {
    AND?: clientsScalarWhereWithAggregatesInput | clientsScalarWhereWithAggregatesInput[]
    OR?: clientsScalarWhereWithAggregatesInput[]
    NOT?: clientsScalarWhereWithAggregatesInput | clientsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"clients"> | number
    name?: StringWithAggregatesFilter<"clients"> | string
    masked_description?: StringNullableWithAggregatesFilter<"clients"> | string | null
    address?: StringNullableWithAggregatesFilter<"clients"> | string | null
    phone?: StringNullableWithAggregatesFilter<"clients"> | string | null
    npwp?: StringNullableWithAggregatesFilter<"clients"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"clients"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"clients"> | Date | string | null
  }

  export type documentsWhereInput = {
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    id?: IntFilter<"documents"> | number
    document_types?: Enumdocument_typesNullableFilter<"documents"> | $Enums.document_types | null
    number?: StringFilter<"documents"> | string
    date_created?: DateTimeNullableFilter<"documents"> | Date | string | null
    date_signed?: DateTimeNullableFilter<"documents"> | Date | string | null
    document_url?: StringNullableFilter<"documents"> | string | null
    project_id?: IntFilter<"documents"> | number
    client_pic_id?: IntFilter<"documents"> | number
    client_id?: IntFilter<"documents"> | number
    clients?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    client_pics?: XOR<Client_picsScalarRelationFilter, client_picsWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, projectsWhereInput>
  }

  export type documentsOrderByWithRelationInput = {
    id?: SortOrder
    document_types?: SortOrderInput | SortOrder
    number?: SortOrder
    date_created?: SortOrderInput | SortOrder
    date_signed?: SortOrderInput | SortOrder
    document_url?: SortOrderInput | SortOrder
    project_id?: SortOrder
    client_pic_id?: SortOrder
    client_id?: SortOrder
    clients?: clientsOrderByWithRelationInput
    client_pics?: client_picsOrderByWithRelationInput
    projects?: projectsOrderByWithRelationInput
  }

  export type documentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: documentsWhereInput | documentsWhereInput[]
    OR?: documentsWhereInput[]
    NOT?: documentsWhereInput | documentsWhereInput[]
    document_types?: Enumdocument_typesNullableFilter<"documents"> | $Enums.document_types | null
    number?: StringFilter<"documents"> | string
    date_created?: DateTimeNullableFilter<"documents"> | Date | string | null
    date_signed?: DateTimeNullableFilter<"documents"> | Date | string | null
    document_url?: StringNullableFilter<"documents"> | string | null
    project_id?: IntFilter<"documents"> | number
    client_pic_id?: IntFilter<"documents"> | number
    client_id?: IntFilter<"documents"> | number
    clients?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    client_pics?: XOR<Client_picsScalarRelationFilter, client_picsWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, projectsWhereInput>
  }, "id">

  export type documentsOrderByWithAggregationInput = {
    id?: SortOrder
    document_types?: SortOrderInput | SortOrder
    number?: SortOrder
    date_created?: SortOrderInput | SortOrder
    date_signed?: SortOrderInput | SortOrder
    document_url?: SortOrderInput | SortOrder
    project_id?: SortOrder
    client_pic_id?: SortOrder
    client_id?: SortOrder
    _count?: documentsCountOrderByAggregateInput
    _avg?: documentsAvgOrderByAggregateInput
    _max?: documentsMaxOrderByAggregateInput
    _min?: documentsMinOrderByAggregateInput
    _sum?: documentsSumOrderByAggregateInput
  }

  export type documentsScalarWhereWithAggregatesInput = {
    AND?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    OR?: documentsScalarWhereWithAggregatesInput[]
    NOT?: documentsScalarWhereWithAggregatesInput | documentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"documents"> | number
    document_types?: Enumdocument_typesNullableWithAggregatesFilter<"documents"> | $Enums.document_types | null
    number?: StringWithAggregatesFilter<"documents"> | string
    date_created?: DateTimeNullableWithAggregatesFilter<"documents"> | Date | string | null
    date_signed?: DateTimeNullableWithAggregatesFilter<"documents"> | Date | string | null
    document_url?: StringNullableWithAggregatesFilter<"documents"> | string | null
    project_id?: IntWithAggregatesFilter<"documents"> | number
    client_pic_id?: IntWithAggregatesFilter<"documents"> | number
    client_id?: IntWithAggregatesFilter<"documents"> | number
  }

  export type employeesWhereInput = {
    AND?: employeesWhereInput | employeesWhereInput[]
    OR?: employeesWhereInput[]
    NOT?: employeesWhereInput | employeesWhereInput[]
    id?: IntFilter<"employees"> | number
    nik?: StringFilter<"employees"> | string
    nip?: StringFilter<"employees"> | string
    name?: StringFilter<"employees"> | string
    email?: StringFilter<"employees"> | string
    phone?: StringFilter<"employees"> | string
    address?: StringFilter<"employees"> | string
    position?: StringFilter<"employees"> | string
    status?: Enumstatus_employeesFilter<"employees"> | $Enums.status_employees
    password?: StringNullableFilter<"employees"> | string | null
    refresh_token?: StringNullableFilter<"employees"> | string | null
    project_team_members?: Project_team_membersListRelationFilter
    project_teams_project_teams_auditor_idToemployees?: Project_teamsListRelationFilter
    project_teams_project_teams_manager_idToemployees?: Project_teamsListRelationFilter
  }

  export type employeesOrderByWithRelationInput = {
    id?: SortOrder
    nik?: SortOrder
    nip?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    position?: SortOrder
    status?: SortOrder
    password?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    project_team_members?: project_team_membersOrderByRelationAggregateInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsOrderByRelationAggregateInput
    project_teams_project_teams_manager_idToemployees?: project_teamsOrderByRelationAggregateInput
  }

  export type employeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: employeesWhereInput | employeesWhereInput[]
    OR?: employeesWhereInput[]
    NOT?: employeesWhereInput | employeesWhereInput[]
    nik?: StringFilter<"employees"> | string
    nip?: StringFilter<"employees"> | string
    name?: StringFilter<"employees"> | string
    phone?: StringFilter<"employees"> | string
    address?: StringFilter<"employees"> | string
    position?: StringFilter<"employees"> | string
    status?: Enumstatus_employeesFilter<"employees"> | $Enums.status_employees
    password?: StringNullableFilter<"employees"> | string | null
    refresh_token?: StringNullableFilter<"employees"> | string | null
    project_team_members?: Project_team_membersListRelationFilter
    project_teams_project_teams_auditor_idToemployees?: Project_teamsListRelationFilter
    project_teams_project_teams_manager_idToemployees?: Project_teamsListRelationFilter
  }, "id" | "email">

  export type employeesOrderByWithAggregationInput = {
    id?: SortOrder
    nik?: SortOrder
    nip?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    position?: SortOrder
    status?: SortOrder
    password?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    _count?: employeesCountOrderByAggregateInput
    _avg?: employeesAvgOrderByAggregateInput
    _max?: employeesMaxOrderByAggregateInput
    _min?: employeesMinOrderByAggregateInput
    _sum?: employeesSumOrderByAggregateInput
  }

  export type employeesScalarWhereWithAggregatesInput = {
    AND?: employeesScalarWhereWithAggregatesInput | employeesScalarWhereWithAggregatesInput[]
    OR?: employeesScalarWhereWithAggregatesInput[]
    NOT?: employeesScalarWhereWithAggregatesInput | employeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employees"> | number
    nik?: StringWithAggregatesFilter<"employees"> | string
    nip?: StringWithAggregatesFilter<"employees"> | string
    name?: StringWithAggregatesFilter<"employees"> | string
    email?: StringWithAggregatesFilter<"employees"> | string
    phone?: StringWithAggregatesFilter<"employees"> | string
    address?: StringWithAggregatesFilter<"employees"> | string
    position?: StringWithAggregatesFilter<"employees"> | string
    status?: Enumstatus_employeesWithAggregatesFilter<"employees"> | $Enums.status_employees
    password?: StringNullableWithAggregatesFilter<"employees"> | string | null
    refresh_token?: StringNullableWithAggregatesFilter<"employees"> | string | null
  }

  export type project_team_membersWhereInput = {
    AND?: project_team_membersWhereInput | project_team_membersWhereInput[]
    OR?: project_team_membersWhereInput[]
    NOT?: project_team_membersWhereInput | project_team_membersWhereInput[]
    id?: IntFilter<"project_team_members"> | number
    role_id?: IntFilter<"project_team_members"> | number
    project_teams_id?: IntFilter<"project_team_members"> | number
    job_description?: StringNullableFilter<"project_team_members"> | string | null
    end_at?: DateTimeNullableFilter<"project_team_members"> | Date | string | null
    employee_id?: IntFilter<"project_team_members"> | number
    employees?: XOR<EmployeesScalarRelationFilter, employeesWhereInput>
    project_teams?: XOR<Project_teamsScalarRelationFilter, project_teamsWhereInput>
    role_levels?: XOR<Role_levelsScalarRelationFilter, role_levelsWhereInput>
  }

  export type project_team_membersOrderByWithRelationInput = {
    id?: SortOrder
    role_id?: SortOrder
    project_teams_id?: SortOrder
    job_description?: SortOrderInput | SortOrder
    end_at?: SortOrderInput | SortOrder
    employee_id?: SortOrder
    employees?: employeesOrderByWithRelationInput
    project_teams?: project_teamsOrderByWithRelationInput
    role_levels?: role_levelsOrderByWithRelationInput
  }

  export type project_team_membersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: project_team_membersWhereInput | project_team_membersWhereInput[]
    OR?: project_team_membersWhereInput[]
    NOT?: project_team_membersWhereInput | project_team_membersWhereInput[]
    role_id?: IntFilter<"project_team_members"> | number
    project_teams_id?: IntFilter<"project_team_members"> | number
    job_description?: StringNullableFilter<"project_team_members"> | string | null
    end_at?: DateTimeNullableFilter<"project_team_members"> | Date | string | null
    employee_id?: IntFilter<"project_team_members"> | number
    employees?: XOR<EmployeesScalarRelationFilter, employeesWhereInput>
    project_teams?: XOR<Project_teamsScalarRelationFilter, project_teamsWhereInput>
    role_levels?: XOR<Role_levelsScalarRelationFilter, role_levelsWhereInput>
  }, "id">

  export type project_team_membersOrderByWithAggregationInput = {
    id?: SortOrder
    role_id?: SortOrder
    project_teams_id?: SortOrder
    job_description?: SortOrderInput | SortOrder
    end_at?: SortOrderInput | SortOrder
    employee_id?: SortOrder
    _count?: project_team_membersCountOrderByAggregateInput
    _avg?: project_team_membersAvgOrderByAggregateInput
    _max?: project_team_membersMaxOrderByAggregateInput
    _min?: project_team_membersMinOrderByAggregateInput
    _sum?: project_team_membersSumOrderByAggregateInput
  }

  export type project_team_membersScalarWhereWithAggregatesInput = {
    AND?: project_team_membersScalarWhereWithAggregatesInput | project_team_membersScalarWhereWithAggregatesInput[]
    OR?: project_team_membersScalarWhereWithAggregatesInput[]
    NOT?: project_team_membersScalarWhereWithAggregatesInput | project_team_membersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"project_team_members"> | number
    role_id?: IntWithAggregatesFilter<"project_team_members"> | number
    project_teams_id?: IntWithAggregatesFilter<"project_team_members"> | number
    job_description?: StringNullableWithAggregatesFilter<"project_team_members"> | string | null
    end_at?: DateTimeNullableWithAggregatesFilter<"project_team_members"> | Date | string | null
    employee_id?: IntWithAggregatesFilter<"project_team_members"> | number
  }

  export type project_teamsWhereInput = {
    AND?: project_teamsWhereInput | project_teamsWhereInput[]
    OR?: project_teamsWhereInput[]
    NOT?: project_teamsWhereInput | project_teamsWhereInput[]
    id?: IntFilter<"project_teams"> | number
    project_teams_name?: StringFilter<"project_teams"> | string
    project_teams_email?: StringFilter<"project_teams"> | string
    manager_id?: IntFilter<"project_teams"> | number
    auditor_id?: IntNullableFilter<"project_teams"> | number | null
    project_id?: IntFilter<"project_teams"> | number
    project_team_members?: Project_team_membersListRelationFilter
    employees_project_teams_auditor_idToemployees?: XOR<EmployeesNullableScalarRelationFilter, employeesWhereInput> | null
    employees_project_teams_manager_idToemployees?: XOR<EmployeesScalarRelationFilter, employeesWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, projectsWhereInput>
  }

  export type project_teamsOrderByWithRelationInput = {
    id?: SortOrder
    project_teams_name?: SortOrder
    project_teams_email?: SortOrder
    manager_id?: SortOrder
    auditor_id?: SortOrderInput | SortOrder
    project_id?: SortOrder
    project_team_members?: project_team_membersOrderByRelationAggregateInput
    employees_project_teams_auditor_idToemployees?: employeesOrderByWithRelationInput
    employees_project_teams_manager_idToemployees?: employeesOrderByWithRelationInput
    projects?: projectsOrderByWithRelationInput
  }

  export type project_teamsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: project_teamsWhereInput | project_teamsWhereInput[]
    OR?: project_teamsWhereInput[]
    NOT?: project_teamsWhereInput | project_teamsWhereInput[]
    project_teams_name?: StringFilter<"project_teams"> | string
    project_teams_email?: StringFilter<"project_teams"> | string
    manager_id?: IntFilter<"project_teams"> | number
    auditor_id?: IntNullableFilter<"project_teams"> | number | null
    project_id?: IntFilter<"project_teams"> | number
    project_team_members?: Project_team_membersListRelationFilter
    employees_project_teams_auditor_idToemployees?: XOR<EmployeesNullableScalarRelationFilter, employeesWhereInput> | null
    employees_project_teams_manager_idToemployees?: XOR<EmployeesScalarRelationFilter, employeesWhereInput>
    projects?: XOR<ProjectsScalarRelationFilter, projectsWhereInput>
  }, "id">

  export type project_teamsOrderByWithAggregationInput = {
    id?: SortOrder
    project_teams_name?: SortOrder
    project_teams_email?: SortOrder
    manager_id?: SortOrder
    auditor_id?: SortOrderInput | SortOrder
    project_id?: SortOrder
    _count?: project_teamsCountOrderByAggregateInput
    _avg?: project_teamsAvgOrderByAggregateInput
    _max?: project_teamsMaxOrderByAggregateInput
    _min?: project_teamsMinOrderByAggregateInput
    _sum?: project_teamsSumOrderByAggregateInput
  }

  export type project_teamsScalarWhereWithAggregatesInput = {
    AND?: project_teamsScalarWhereWithAggregatesInput | project_teamsScalarWhereWithAggregatesInput[]
    OR?: project_teamsScalarWhereWithAggregatesInput[]
    NOT?: project_teamsScalarWhereWithAggregatesInput | project_teamsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"project_teams"> | number
    project_teams_name?: StringWithAggregatesFilter<"project_teams"> | string
    project_teams_email?: StringWithAggregatesFilter<"project_teams"> | string
    manager_id?: IntWithAggregatesFilter<"project_teams"> | number
    auditor_id?: IntNullableWithAggregatesFilter<"project_teams"> | number | null
    project_id?: IntWithAggregatesFilter<"project_teams"> | number
  }

  export type projectsWhereInput = {
    AND?: projectsWhereInput | projectsWhereInput[]
    OR?: projectsWhereInput[]
    NOT?: projectsWhereInput | projectsWhereInput[]
    id?: IntFilter<"projects"> | number
    client_id?: IntFilter<"projects"> | number
    project_name?: StringFilter<"projects"> | string
    project_code?: StringFilter<"projects"> | string
    project_type?: Enumproject_typesFilter<"projects"> | $Enums.project_types
    contract_value?: DecimalNullableFilter<"projects"> | Decimal | DecimalJsLike | number | string | null
    started_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    is_deleted?: BoolNullableFilter<"projects"> | boolean | null
    client_pics?: Client_picsListRelationFilter
    documents?: DocumentsListRelationFilter
    project_teams?: Project_teamsListRelationFilter
    clients?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
  }

  export type projectsOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrder
    project_name?: SortOrder
    project_code?: SortOrder
    project_type?: SortOrder
    contract_value?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_deleted?: SortOrderInput | SortOrder
    client_pics?: client_picsOrderByRelationAggregateInput
    documents?: documentsOrderByRelationAggregateInput
    project_teams?: project_teamsOrderByRelationAggregateInput
    clients?: clientsOrderByWithRelationInput
  }

  export type projectsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    project_code?: string
    AND?: projectsWhereInput | projectsWhereInput[]
    OR?: projectsWhereInput[]
    NOT?: projectsWhereInput | projectsWhereInput[]
    client_id?: IntFilter<"projects"> | number
    project_name?: StringFilter<"projects"> | string
    project_type?: Enumproject_typesFilter<"projects"> | $Enums.project_types
    contract_value?: DecimalNullableFilter<"projects"> | Decimal | DecimalJsLike | number | string | null
    started_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    is_deleted?: BoolNullableFilter<"projects"> | boolean | null
    client_pics?: Client_picsListRelationFilter
    documents?: DocumentsListRelationFilter
    project_teams?: Project_teamsListRelationFilter
    clients?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
  }, "id" | "project_code">

  export type projectsOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrder
    project_name?: SortOrder
    project_code?: SortOrder
    project_type?: SortOrder
    contract_value?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    finished_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_deleted?: SortOrderInput | SortOrder
    _count?: projectsCountOrderByAggregateInput
    _avg?: projectsAvgOrderByAggregateInput
    _max?: projectsMaxOrderByAggregateInput
    _min?: projectsMinOrderByAggregateInput
    _sum?: projectsSumOrderByAggregateInput
  }

  export type projectsScalarWhereWithAggregatesInput = {
    AND?: projectsScalarWhereWithAggregatesInput | projectsScalarWhereWithAggregatesInput[]
    OR?: projectsScalarWhereWithAggregatesInput[]
    NOT?: projectsScalarWhereWithAggregatesInput | projectsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"projects"> | number
    client_id?: IntWithAggregatesFilter<"projects"> | number
    project_name?: StringWithAggregatesFilter<"projects"> | string
    project_code?: StringWithAggregatesFilter<"projects"> | string
    project_type?: Enumproject_typesWithAggregatesFilter<"projects"> | $Enums.project_types
    contract_value?: DecimalNullableWithAggregatesFilter<"projects"> | Decimal | DecimalJsLike | number | string | null
    started_at?: DateTimeNullableWithAggregatesFilter<"projects"> | Date | string | null
    finished_at?: DateTimeNullableWithAggregatesFilter<"projects"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"projects"> | Date | string | null
    is_deleted?: BoolNullableWithAggregatesFilter<"projects"> | boolean | null
  }

  export type role_levelsWhereInput = {
    AND?: role_levelsWhereInput | role_levelsWhereInput[]
    OR?: role_levelsWhereInput[]
    NOT?: role_levelsWhereInput | role_levelsWhereInput[]
    id?: IntFilter<"role_levels"> | number
    role_name?: StringNullableFilter<"role_levels"> | string | null
    role_level?: IntNullableFilter<"role_levels"> | number | null
    role_price?: DecimalNullableFilter<"role_levels"> | Decimal | DecimalJsLike | number | string | null
    is_default?: BoolNullableFilter<"role_levels"> | boolean | null
    project_team_members?: Project_team_membersListRelationFilter
  }

  export type role_levelsOrderByWithRelationInput = {
    id?: SortOrder
    role_name?: SortOrderInput | SortOrder
    role_level?: SortOrderInput | SortOrder
    role_price?: SortOrderInput | SortOrder
    is_default?: SortOrderInput | SortOrder
    project_team_members?: project_team_membersOrderByRelationAggregateInput
  }

  export type role_levelsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: role_levelsWhereInput | role_levelsWhereInput[]
    OR?: role_levelsWhereInput[]
    NOT?: role_levelsWhereInput | role_levelsWhereInput[]
    role_name?: StringNullableFilter<"role_levels"> | string | null
    role_level?: IntNullableFilter<"role_levels"> | number | null
    role_price?: DecimalNullableFilter<"role_levels"> | Decimal | DecimalJsLike | number | string | null
    is_default?: BoolNullableFilter<"role_levels"> | boolean | null
    project_team_members?: Project_team_membersListRelationFilter
  }, "id">

  export type role_levelsOrderByWithAggregationInput = {
    id?: SortOrder
    role_name?: SortOrderInput | SortOrder
    role_level?: SortOrderInput | SortOrder
    role_price?: SortOrderInput | SortOrder
    is_default?: SortOrderInput | SortOrder
    _count?: role_levelsCountOrderByAggregateInput
    _avg?: role_levelsAvgOrderByAggregateInput
    _max?: role_levelsMaxOrderByAggregateInput
    _min?: role_levelsMinOrderByAggregateInput
    _sum?: role_levelsSumOrderByAggregateInput
  }

  export type role_levelsScalarWhereWithAggregatesInput = {
    AND?: role_levelsScalarWhereWithAggregatesInput | role_levelsScalarWhereWithAggregatesInput[]
    OR?: role_levelsScalarWhereWithAggregatesInput[]
    NOT?: role_levelsScalarWhereWithAggregatesInput | role_levelsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"role_levels"> | number
    role_name?: StringNullableWithAggregatesFilter<"role_levels"> | string | null
    role_level?: IntNullableWithAggregatesFilter<"role_levels"> | number | null
    role_price?: DecimalNullableWithAggregatesFilter<"role_levels"> | Decimal | DecimalJsLike | number | string | null
    is_default?: BoolNullableWithAggregatesFilter<"role_levels"> | boolean | null
  }

  export type client_picsCreateInput = {
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    clients: clientsCreateNestedOneWithoutClient_picsInput
    projects: projectsCreateNestedOneWithoutClient_picsInput
    documents?: documentsCreateNestedManyWithoutClient_picsInput
  }

  export type client_picsUncheckedCreateInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    project_id: number
    client_id: number
    documents?: documentsUncheckedCreateNestedManyWithoutClient_picsInput
  }

  export type client_picsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: clientsUpdateOneRequiredWithoutClient_picsNestedInput
    projects?: projectsUpdateOneRequiredWithoutClient_picsNestedInput
    documents?: documentsUpdateManyWithoutClient_picsNestedInput
  }

  export type client_picsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    documents?: documentsUncheckedUpdateManyWithoutClient_picsNestedInput
  }

  export type client_picsCreateManyInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    project_id: number
    client_id: number
  }

  export type client_picsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type client_picsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type clientsCreateInput = {
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    client_pics?: client_picsCreateNestedManyWithoutClientsInput
    documents?: documentsCreateNestedManyWithoutClientsInput
    projects?: projectsCreateNestedManyWithoutClientsInput
  }

  export type clientsUncheckedCreateInput = {
    id?: number
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    client_pics?: client_picsUncheckedCreateNestedManyWithoutClientsInput
    documents?: documentsUncheckedCreateNestedManyWithoutClientsInput
    projects?: projectsUncheckedCreateNestedManyWithoutClientsInput
  }

  export type clientsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client_pics?: client_picsUpdateManyWithoutClientsNestedInput
    documents?: documentsUpdateManyWithoutClientsNestedInput
    projects?: projectsUpdateManyWithoutClientsNestedInput
  }

  export type clientsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client_pics?: client_picsUncheckedUpdateManyWithoutClientsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutClientsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutClientsNestedInput
  }

  export type clientsCreateManyInput = {
    id?: number
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type clientsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type documentsCreateInput = {
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    clients: clientsCreateNestedOneWithoutDocumentsInput
    client_pics: client_picsCreateNestedOneWithoutDocumentsInput
    projects: projectsCreateNestedOneWithoutDocumentsInput
  }

  export type documentsUncheckedCreateInput = {
    id?: number
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    project_id: number
    client_pic_id: number
    client_id: number
  }

  export type documentsUpdateInput = {
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: clientsUpdateOneRequiredWithoutDocumentsNestedInput
    client_pics?: client_picsUpdateOneRequiredWithoutDocumentsNestedInput
    projects?: projectsUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type documentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_pic_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type documentsCreateManyInput = {
    id?: number
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    project_id: number
    client_pic_id: number
    client_id: number
  }

  export type documentsUpdateManyMutationInput = {
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type documentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_pic_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type employeesCreateInput = {
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
    project_team_members?: project_team_membersCreateNestedManyWithoutEmployeesInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsCreateNestedManyWithoutEmployees_project_teams_auditor_idToemployeesInput
    project_teams_project_teams_manager_idToemployees?: project_teamsCreateNestedManyWithoutEmployees_project_teams_manager_idToemployeesInput
  }

  export type employeesUncheckedCreateInput = {
    id?: number
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
    project_team_members?: project_team_membersUncheckedCreateNestedManyWithoutEmployeesInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsUncheckedCreateNestedManyWithoutEmployees_project_teams_auditor_idToemployeesInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUncheckedCreateNestedManyWithoutEmployees_project_teams_manager_idToemployeesInput
  }

  export type employeesUpdateInput = {
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    project_team_members?: project_team_membersUpdateManyWithoutEmployeesNestedInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesNestedInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUpdateManyWithoutEmployees_project_teams_manager_idToemployeesNestedInput
  }

  export type employeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    project_team_members?: project_team_membersUncheckedUpdateManyWithoutEmployeesNestedInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesNestedInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_manager_idToemployeesNestedInput
  }

  export type employeesCreateManyInput = {
    id?: number
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
  }

  export type employeesUpdateManyMutationInput = {
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_team_membersCreateInput = {
    job_description?: string | null
    end_at?: Date | string | null
    employees: employeesCreateNestedOneWithoutProject_team_membersInput
    project_teams: project_teamsCreateNestedOneWithoutProject_team_membersInput
    role_levels: role_levelsCreateNestedOneWithoutProject_team_membersInput
  }

  export type project_team_membersUncheckedCreateInput = {
    id?: number
    role_id: number
    project_teams_id: number
    job_description?: string | null
    end_at?: Date | string | null
    employee_id: number
  }

  export type project_team_membersUpdateInput = {
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: employeesUpdateOneRequiredWithoutProject_team_membersNestedInput
    project_teams?: project_teamsUpdateOneRequiredWithoutProject_team_membersNestedInput
    role_levels?: role_levelsUpdateOneRequiredWithoutProject_team_membersNestedInput
  }

  export type project_team_membersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    project_teams_id?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type project_team_membersCreateManyInput = {
    id?: number
    role_id: number
    project_teams_id: number
    job_description?: string | null
    end_at?: Date | string | null
    employee_id: number
  }

  export type project_team_membersUpdateManyMutationInput = {
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type project_team_membersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    project_teams_id?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type project_teamsCreateInput = {
    project_teams_name: string
    project_teams_email: string
    project_team_members?: project_team_membersCreateNestedManyWithoutProject_teamsInput
    employees_project_teams_auditor_idToemployees?: employeesCreateNestedOneWithoutProject_teams_project_teams_auditor_idToemployeesInput
    employees_project_teams_manager_idToemployees: employeesCreateNestedOneWithoutProject_teams_project_teams_manager_idToemployeesInput
    projects: projectsCreateNestedOneWithoutProject_teamsInput
  }

  export type project_teamsUncheckedCreateInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    manager_id: number
    auditor_id?: number | null
    project_id: number
    project_team_members?: project_team_membersUncheckedCreateNestedManyWithoutProject_teamsInput
  }

  export type project_teamsUpdateInput = {
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    project_team_members?: project_team_membersUpdateManyWithoutProject_teamsNestedInput
    employees_project_teams_auditor_idToemployees?: employeesUpdateOneWithoutProject_teams_project_teams_auditor_idToemployeesNestedInput
    employees_project_teams_manager_idToemployees?: employeesUpdateOneRequiredWithoutProject_teams_project_teams_manager_idToemployeesNestedInput
    projects?: projectsUpdateOneRequiredWithoutProject_teamsNestedInput
  }

  export type project_teamsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    manager_id?: IntFieldUpdateOperationsInput | number
    auditor_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: IntFieldUpdateOperationsInput | number
    project_team_members?: project_team_membersUncheckedUpdateManyWithoutProject_teamsNestedInput
  }

  export type project_teamsCreateManyInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    manager_id: number
    auditor_id?: number | null
    project_id: number
  }

  export type project_teamsUpdateManyMutationInput = {
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
  }

  export type project_teamsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    manager_id?: IntFieldUpdateOperationsInput | number
    auditor_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: IntFieldUpdateOperationsInput | number
  }

  export type projectsCreateInput = {
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    client_pics?: client_picsCreateNestedManyWithoutProjectsInput
    documents?: documentsCreateNestedManyWithoutProjectsInput
    project_teams?: project_teamsCreateNestedManyWithoutProjectsInput
    clients: clientsCreateNestedOneWithoutProjectsInput
  }

  export type projectsUncheckedCreateInput = {
    id?: number
    client_id: number
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    client_pics?: client_picsUncheckedCreateNestedManyWithoutProjectsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjectsInput
    project_teams?: project_teamsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type projectsUpdateInput = {
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_pics?: client_picsUpdateManyWithoutProjectsNestedInput
    documents?: documentsUpdateManyWithoutProjectsNestedInput
    project_teams?: project_teamsUpdateManyWithoutProjectsNestedInput
    clients?: clientsUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type projectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_pics?: client_picsUncheckedUpdateManyWithoutProjectsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjectsNestedInput
    project_teams?: project_teamsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type projectsCreateManyInput = {
    id?: number
    client_id: number
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
  }

  export type projectsUpdateManyMutationInput = {
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type projectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type role_levelsCreateInput = {
    role_name?: string | null
    role_level?: number | null
    role_price?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
    project_team_members?: project_team_membersCreateNestedManyWithoutRole_levelsInput
  }

  export type role_levelsUncheckedCreateInput = {
    id?: number
    role_name?: string | null
    role_level?: number | null
    role_price?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
    project_team_members?: project_team_membersUncheckedCreateNestedManyWithoutRole_levelsInput
  }

  export type role_levelsUpdateInput = {
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_level?: NullableIntFieldUpdateOperationsInput | number | null
    role_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    project_team_members?: project_team_membersUpdateManyWithoutRole_levelsNestedInput
  }

  export type role_levelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_level?: NullableIntFieldUpdateOperationsInput | number | null
    role_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
    project_team_members?: project_team_membersUncheckedUpdateManyWithoutRole_levelsNestedInput
  }

  export type role_levelsCreateManyInput = {
    id?: number
    role_name?: string | null
    role_level?: number | null
    role_price?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
  }

  export type role_levelsUpdateManyMutationInput = {
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_level?: NullableIntFieldUpdateOperationsInput | number | null
    role_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type role_levelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_level?: NullableIntFieldUpdateOperationsInput | number | null
    role_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ClientsScalarRelationFilter = {
    is?: clientsWhereInput
    isNot?: clientsWhereInput
  }

  export type ProjectsScalarRelationFilter = {
    is?: projectsWhereInput
    isNot?: projectsWhereInput
  }

  export type DocumentsListRelationFilter = {
    every?: documentsWhereInput
    some?: documentsWhereInput
    none?: documentsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type documentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type client_picsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
  }

  export type client_picsAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
  }

  export type client_picsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
  }

  export type client_picsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
  }

  export type client_picsSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Client_picsListRelationFilter = {
    every?: client_picsWhereInput
    some?: client_picsWhereInput
    none?: client_picsWhereInput
  }

  export type ProjectsListRelationFilter = {
    every?: projectsWhereInput
    some?: projectsWhereInput
    none?: projectsWhereInput
  }

  export type client_picsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    masked_description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    npwp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type clientsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    masked_description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    npwp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    masked_description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    npwp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type clientsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumdocument_typesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.document_types | Enumdocument_typesFieldRefInput<$PrismaModel> | null
    in?: $Enums.document_types[] | ListEnumdocument_typesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.document_types[] | ListEnumdocument_typesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumdocument_typesNullableFilter<$PrismaModel> | $Enums.document_types | null
  }

  export type Client_picsScalarRelationFilter = {
    is?: client_picsWhereInput
    isNot?: client_picsWhereInput
  }

  export type documentsCountOrderByAggregateInput = {
    id?: SortOrder
    document_types?: SortOrder
    number?: SortOrder
    date_created?: SortOrder
    date_signed?: SortOrder
    document_url?: SortOrder
    project_id?: SortOrder
    client_pic_id?: SortOrder
    client_id?: SortOrder
  }

  export type documentsAvgOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_pic_id?: SortOrder
    client_id?: SortOrder
  }

  export type documentsMaxOrderByAggregateInput = {
    id?: SortOrder
    document_types?: SortOrder
    number?: SortOrder
    date_created?: SortOrder
    date_signed?: SortOrder
    document_url?: SortOrder
    project_id?: SortOrder
    client_pic_id?: SortOrder
    client_id?: SortOrder
  }

  export type documentsMinOrderByAggregateInput = {
    id?: SortOrder
    document_types?: SortOrder
    number?: SortOrder
    date_created?: SortOrder
    date_signed?: SortOrder
    document_url?: SortOrder
    project_id?: SortOrder
    client_pic_id?: SortOrder
    client_id?: SortOrder
  }

  export type documentsSumOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_pic_id?: SortOrder
    client_id?: SortOrder
  }

  export type Enumdocument_typesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.document_types | Enumdocument_typesFieldRefInput<$PrismaModel> | null
    in?: $Enums.document_types[] | ListEnumdocument_typesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.document_types[] | ListEnumdocument_typesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumdocument_typesNullableWithAggregatesFilter<$PrismaModel> | $Enums.document_types | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumdocument_typesNullableFilter<$PrismaModel>
    _max?: NestedEnumdocument_typesNullableFilter<$PrismaModel>
  }

  export type Enumstatus_employeesFilter<$PrismaModel = never> = {
    equals?: $Enums.status_employees | Enumstatus_employeesFieldRefInput<$PrismaModel>
    in?: $Enums.status_employees[] | ListEnumstatus_employeesFieldRefInput<$PrismaModel>
    notIn?: $Enums.status_employees[] | ListEnumstatus_employeesFieldRefInput<$PrismaModel>
    not?: NestedEnumstatus_employeesFilter<$PrismaModel> | $Enums.status_employees
  }

  export type Project_team_membersListRelationFilter = {
    every?: project_team_membersWhereInput
    some?: project_team_membersWhereInput
    none?: project_team_membersWhereInput
  }

  export type Project_teamsListRelationFilter = {
    every?: project_teamsWhereInput
    some?: project_teamsWhereInput
    none?: project_teamsWhereInput
  }

  export type project_team_membersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type project_teamsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeesCountOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nip?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    position?: SortOrder
    status?: SortOrder
    password?: SortOrder
    refresh_token?: SortOrder
  }

  export type employeesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type employeesMaxOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nip?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    position?: SortOrder
    status?: SortOrder
    password?: SortOrder
    refresh_token?: SortOrder
  }

  export type employeesMinOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nip?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    position?: SortOrder
    status?: SortOrder
    password?: SortOrder
    refresh_token?: SortOrder
  }

  export type employeesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumstatus_employeesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.status_employees | Enumstatus_employeesFieldRefInput<$PrismaModel>
    in?: $Enums.status_employees[] | ListEnumstatus_employeesFieldRefInput<$PrismaModel>
    notIn?: $Enums.status_employees[] | ListEnumstatus_employeesFieldRefInput<$PrismaModel>
    not?: NestedEnumstatus_employeesWithAggregatesFilter<$PrismaModel> | $Enums.status_employees
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstatus_employeesFilter<$PrismaModel>
    _max?: NestedEnumstatus_employeesFilter<$PrismaModel>
  }

  export type EmployeesScalarRelationFilter = {
    is?: employeesWhereInput
    isNot?: employeesWhereInput
  }

  export type Project_teamsScalarRelationFilter = {
    is?: project_teamsWhereInput
    isNot?: project_teamsWhereInput
  }

  export type Role_levelsScalarRelationFilter = {
    is?: role_levelsWhereInput
    isNot?: role_levelsWhereInput
  }

  export type project_team_membersCountOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    project_teams_id?: SortOrder
    job_description?: SortOrder
    end_at?: SortOrder
    employee_id?: SortOrder
  }

  export type project_team_membersAvgOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    project_teams_id?: SortOrder
    employee_id?: SortOrder
  }

  export type project_team_membersMaxOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    project_teams_id?: SortOrder
    job_description?: SortOrder
    end_at?: SortOrder
    employee_id?: SortOrder
  }

  export type project_team_membersMinOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    project_teams_id?: SortOrder
    job_description?: SortOrder
    end_at?: SortOrder
    employee_id?: SortOrder
  }

  export type project_team_membersSumOrderByAggregateInput = {
    id?: SortOrder
    role_id?: SortOrder
    project_teams_id?: SortOrder
    employee_id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EmployeesNullableScalarRelationFilter = {
    is?: employeesWhereInput | null
    isNot?: employeesWhereInput | null
  }

  export type project_teamsCountOrderByAggregateInput = {
    id?: SortOrder
    project_teams_name?: SortOrder
    project_teams_email?: SortOrder
    manager_id?: SortOrder
    auditor_id?: SortOrder
    project_id?: SortOrder
  }

  export type project_teamsAvgOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
    auditor_id?: SortOrder
    project_id?: SortOrder
  }

  export type project_teamsMaxOrderByAggregateInput = {
    id?: SortOrder
    project_teams_name?: SortOrder
    project_teams_email?: SortOrder
    manager_id?: SortOrder
    auditor_id?: SortOrder
    project_id?: SortOrder
  }

  export type project_teamsMinOrderByAggregateInput = {
    id?: SortOrder
    project_teams_name?: SortOrder
    project_teams_email?: SortOrder
    manager_id?: SortOrder
    auditor_id?: SortOrder
    project_id?: SortOrder
  }

  export type project_teamsSumOrderByAggregateInput = {
    id?: SortOrder
    manager_id?: SortOrder
    auditor_id?: SortOrder
    project_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Enumproject_typesFilter<$PrismaModel = never> = {
    equals?: $Enums.project_types | Enumproject_typesFieldRefInput<$PrismaModel>
    in?: $Enums.project_types[] | ListEnumproject_typesFieldRefInput<$PrismaModel>
    notIn?: $Enums.project_types[] | ListEnumproject_typesFieldRefInput<$PrismaModel>
    not?: NestedEnumproject_typesFilter<$PrismaModel> | $Enums.project_types
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type projectsCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    project_name?: SortOrder
    project_code?: SortOrder
    project_type?: SortOrder
    contract_value?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type projectsAvgOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    contract_value?: SortOrder
  }

  export type projectsMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    project_name?: SortOrder
    project_code?: SortOrder
    project_type?: SortOrder
    contract_value?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type projectsMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    project_name?: SortOrder
    project_code?: SortOrder
    project_type?: SortOrder
    contract_value?: SortOrder
    started_at?: SortOrder
    finished_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
  }

  export type projectsSumOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    contract_value?: SortOrder
  }

  export type Enumproject_typesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.project_types | Enumproject_typesFieldRefInput<$PrismaModel>
    in?: $Enums.project_types[] | ListEnumproject_typesFieldRefInput<$PrismaModel>
    notIn?: $Enums.project_types[] | ListEnumproject_typesFieldRefInput<$PrismaModel>
    not?: NestedEnumproject_typesWithAggregatesFilter<$PrismaModel> | $Enums.project_types
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumproject_typesFilter<$PrismaModel>
    _max?: NestedEnumproject_typesFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type role_levelsCountOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
    role_level?: SortOrder
    role_price?: SortOrder
    is_default?: SortOrder
  }

  export type role_levelsAvgOrderByAggregateInput = {
    id?: SortOrder
    role_level?: SortOrder
    role_price?: SortOrder
  }

  export type role_levelsMaxOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
    role_level?: SortOrder
    role_price?: SortOrder
    is_default?: SortOrder
  }

  export type role_levelsMinOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
    role_level?: SortOrder
    role_price?: SortOrder
    is_default?: SortOrder
  }

  export type role_levelsSumOrderByAggregateInput = {
    id?: SortOrder
    role_level?: SortOrder
    role_price?: SortOrder
  }

  export type clientsCreateNestedOneWithoutClient_picsInput = {
    create?: XOR<clientsCreateWithoutClient_picsInput, clientsUncheckedCreateWithoutClient_picsInput>
    connectOrCreate?: clientsCreateOrConnectWithoutClient_picsInput
    connect?: clientsWhereUniqueInput
  }

  export type projectsCreateNestedOneWithoutClient_picsInput = {
    create?: XOR<projectsCreateWithoutClient_picsInput, projectsUncheckedCreateWithoutClient_picsInput>
    connectOrCreate?: projectsCreateOrConnectWithoutClient_picsInput
    connect?: projectsWhereUniqueInput
  }

  export type documentsCreateNestedManyWithoutClient_picsInput = {
    create?: XOR<documentsCreateWithoutClient_picsInput, documentsUncheckedCreateWithoutClient_picsInput> | documentsCreateWithoutClient_picsInput[] | documentsUncheckedCreateWithoutClient_picsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutClient_picsInput | documentsCreateOrConnectWithoutClient_picsInput[]
    createMany?: documentsCreateManyClient_picsInputEnvelope
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
  }

  export type documentsUncheckedCreateNestedManyWithoutClient_picsInput = {
    create?: XOR<documentsCreateWithoutClient_picsInput, documentsUncheckedCreateWithoutClient_picsInput> | documentsCreateWithoutClient_picsInput[] | documentsUncheckedCreateWithoutClient_picsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutClient_picsInput | documentsCreateOrConnectWithoutClient_picsInput[]
    createMany?: documentsCreateManyClient_picsInputEnvelope
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type clientsUpdateOneRequiredWithoutClient_picsNestedInput = {
    create?: XOR<clientsCreateWithoutClient_picsInput, clientsUncheckedCreateWithoutClient_picsInput>
    connectOrCreate?: clientsCreateOrConnectWithoutClient_picsInput
    upsert?: clientsUpsertWithoutClient_picsInput
    connect?: clientsWhereUniqueInput
    update?: XOR<XOR<clientsUpdateToOneWithWhereWithoutClient_picsInput, clientsUpdateWithoutClient_picsInput>, clientsUncheckedUpdateWithoutClient_picsInput>
  }

  export type projectsUpdateOneRequiredWithoutClient_picsNestedInput = {
    create?: XOR<projectsCreateWithoutClient_picsInput, projectsUncheckedCreateWithoutClient_picsInput>
    connectOrCreate?: projectsCreateOrConnectWithoutClient_picsInput
    upsert?: projectsUpsertWithoutClient_picsInput
    connect?: projectsWhereUniqueInput
    update?: XOR<XOR<projectsUpdateToOneWithWhereWithoutClient_picsInput, projectsUpdateWithoutClient_picsInput>, projectsUncheckedUpdateWithoutClient_picsInput>
  }

  export type documentsUpdateManyWithoutClient_picsNestedInput = {
    create?: XOR<documentsCreateWithoutClient_picsInput, documentsUncheckedCreateWithoutClient_picsInput> | documentsCreateWithoutClient_picsInput[] | documentsUncheckedCreateWithoutClient_picsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutClient_picsInput | documentsCreateOrConnectWithoutClient_picsInput[]
    upsert?: documentsUpsertWithWhereUniqueWithoutClient_picsInput | documentsUpsertWithWhereUniqueWithoutClient_picsInput[]
    createMany?: documentsCreateManyClient_picsInputEnvelope
    set?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    disconnect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    delete?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    update?: documentsUpdateWithWhereUniqueWithoutClient_picsInput | documentsUpdateWithWhereUniqueWithoutClient_picsInput[]
    updateMany?: documentsUpdateManyWithWhereWithoutClient_picsInput | documentsUpdateManyWithWhereWithoutClient_picsInput[]
    deleteMany?: documentsScalarWhereInput | documentsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type documentsUncheckedUpdateManyWithoutClient_picsNestedInput = {
    create?: XOR<documentsCreateWithoutClient_picsInput, documentsUncheckedCreateWithoutClient_picsInput> | documentsCreateWithoutClient_picsInput[] | documentsUncheckedCreateWithoutClient_picsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutClient_picsInput | documentsCreateOrConnectWithoutClient_picsInput[]
    upsert?: documentsUpsertWithWhereUniqueWithoutClient_picsInput | documentsUpsertWithWhereUniqueWithoutClient_picsInput[]
    createMany?: documentsCreateManyClient_picsInputEnvelope
    set?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    disconnect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    delete?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    update?: documentsUpdateWithWhereUniqueWithoutClient_picsInput | documentsUpdateWithWhereUniqueWithoutClient_picsInput[]
    updateMany?: documentsUpdateManyWithWhereWithoutClient_picsInput | documentsUpdateManyWithWhereWithoutClient_picsInput[]
    deleteMany?: documentsScalarWhereInput | documentsScalarWhereInput[]
  }

  export type client_picsCreateNestedManyWithoutClientsInput = {
    create?: XOR<client_picsCreateWithoutClientsInput, client_picsUncheckedCreateWithoutClientsInput> | client_picsCreateWithoutClientsInput[] | client_picsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: client_picsCreateOrConnectWithoutClientsInput | client_picsCreateOrConnectWithoutClientsInput[]
    createMany?: client_picsCreateManyClientsInputEnvelope
    connect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
  }

  export type documentsCreateNestedManyWithoutClientsInput = {
    create?: XOR<documentsCreateWithoutClientsInput, documentsUncheckedCreateWithoutClientsInput> | documentsCreateWithoutClientsInput[] | documentsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutClientsInput | documentsCreateOrConnectWithoutClientsInput[]
    createMany?: documentsCreateManyClientsInputEnvelope
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
  }

  export type projectsCreateNestedManyWithoutClientsInput = {
    create?: XOR<projectsCreateWithoutClientsInput, projectsUncheckedCreateWithoutClientsInput> | projectsCreateWithoutClientsInput[] | projectsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: projectsCreateOrConnectWithoutClientsInput | projectsCreateOrConnectWithoutClientsInput[]
    createMany?: projectsCreateManyClientsInputEnvelope
    connect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
  }

  export type client_picsUncheckedCreateNestedManyWithoutClientsInput = {
    create?: XOR<client_picsCreateWithoutClientsInput, client_picsUncheckedCreateWithoutClientsInput> | client_picsCreateWithoutClientsInput[] | client_picsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: client_picsCreateOrConnectWithoutClientsInput | client_picsCreateOrConnectWithoutClientsInput[]
    createMany?: client_picsCreateManyClientsInputEnvelope
    connect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
  }

  export type documentsUncheckedCreateNestedManyWithoutClientsInput = {
    create?: XOR<documentsCreateWithoutClientsInput, documentsUncheckedCreateWithoutClientsInput> | documentsCreateWithoutClientsInput[] | documentsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutClientsInput | documentsCreateOrConnectWithoutClientsInput[]
    createMany?: documentsCreateManyClientsInputEnvelope
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
  }

  export type projectsUncheckedCreateNestedManyWithoutClientsInput = {
    create?: XOR<projectsCreateWithoutClientsInput, projectsUncheckedCreateWithoutClientsInput> | projectsCreateWithoutClientsInput[] | projectsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: projectsCreateOrConnectWithoutClientsInput | projectsCreateOrConnectWithoutClientsInput[]
    createMany?: projectsCreateManyClientsInputEnvelope
    connect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type client_picsUpdateManyWithoutClientsNestedInput = {
    create?: XOR<client_picsCreateWithoutClientsInput, client_picsUncheckedCreateWithoutClientsInput> | client_picsCreateWithoutClientsInput[] | client_picsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: client_picsCreateOrConnectWithoutClientsInput | client_picsCreateOrConnectWithoutClientsInput[]
    upsert?: client_picsUpsertWithWhereUniqueWithoutClientsInput | client_picsUpsertWithWhereUniqueWithoutClientsInput[]
    createMany?: client_picsCreateManyClientsInputEnvelope
    set?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    disconnect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    delete?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    connect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    update?: client_picsUpdateWithWhereUniqueWithoutClientsInput | client_picsUpdateWithWhereUniqueWithoutClientsInput[]
    updateMany?: client_picsUpdateManyWithWhereWithoutClientsInput | client_picsUpdateManyWithWhereWithoutClientsInput[]
    deleteMany?: client_picsScalarWhereInput | client_picsScalarWhereInput[]
  }

  export type documentsUpdateManyWithoutClientsNestedInput = {
    create?: XOR<documentsCreateWithoutClientsInput, documentsUncheckedCreateWithoutClientsInput> | documentsCreateWithoutClientsInput[] | documentsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutClientsInput | documentsCreateOrConnectWithoutClientsInput[]
    upsert?: documentsUpsertWithWhereUniqueWithoutClientsInput | documentsUpsertWithWhereUniqueWithoutClientsInput[]
    createMany?: documentsCreateManyClientsInputEnvelope
    set?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    disconnect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    delete?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    update?: documentsUpdateWithWhereUniqueWithoutClientsInput | documentsUpdateWithWhereUniqueWithoutClientsInput[]
    updateMany?: documentsUpdateManyWithWhereWithoutClientsInput | documentsUpdateManyWithWhereWithoutClientsInput[]
    deleteMany?: documentsScalarWhereInput | documentsScalarWhereInput[]
  }

  export type projectsUpdateManyWithoutClientsNestedInput = {
    create?: XOR<projectsCreateWithoutClientsInput, projectsUncheckedCreateWithoutClientsInput> | projectsCreateWithoutClientsInput[] | projectsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: projectsCreateOrConnectWithoutClientsInput | projectsCreateOrConnectWithoutClientsInput[]
    upsert?: projectsUpsertWithWhereUniqueWithoutClientsInput | projectsUpsertWithWhereUniqueWithoutClientsInput[]
    createMany?: projectsCreateManyClientsInputEnvelope
    set?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    disconnect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    delete?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    connect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    update?: projectsUpdateWithWhereUniqueWithoutClientsInput | projectsUpdateWithWhereUniqueWithoutClientsInput[]
    updateMany?: projectsUpdateManyWithWhereWithoutClientsInput | projectsUpdateManyWithWhereWithoutClientsInput[]
    deleteMany?: projectsScalarWhereInput | projectsScalarWhereInput[]
  }

  export type client_picsUncheckedUpdateManyWithoutClientsNestedInput = {
    create?: XOR<client_picsCreateWithoutClientsInput, client_picsUncheckedCreateWithoutClientsInput> | client_picsCreateWithoutClientsInput[] | client_picsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: client_picsCreateOrConnectWithoutClientsInput | client_picsCreateOrConnectWithoutClientsInput[]
    upsert?: client_picsUpsertWithWhereUniqueWithoutClientsInput | client_picsUpsertWithWhereUniqueWithoutClientsInput[]
    createMany?: client_picsCreateManyClientsInputEnvelope
    set?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    disconnect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    delete?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    connect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    update?: client_picsUpdateWithWhereUniqueWithoutClientsInput | client_picsUpdateWithWhereUniqueWithoutClientsInput[]
    updateMany?: client_picsUpdateManyWithWhereWithoutClientsInput | client_picsUpdateManyWithWhereWithoutClientsInput[]
    deleteMany?: client_picsScalarWhereInput | client_picsScalarWhereInput[]
  }

  export type documentsUncheckedUpdateManyWithoutClientsNestedInput = {
    create?: XOR<documentsCreateWithoutClientsInput, documentsUncheckedCreateWithoutClientsInput> | documentsCreateWithoutClientsInput[] | documentsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutClientsInput | documentsCreateOrConnectWithoutClientsInput[]
    upsert?: documentsUpsertWithWhereUniqueWithoutClientsInput | documentsUpsertWithWhereUniqueWithoutClientsInput[]
    createMany?: documentsCreateManyClientsInputEnvelope
    set?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    disconnect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    delete?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    update?: documentsUpdateWithWhereUniqueWithoutClientsInput | documentsUpdateWithWhereUniqueWithoutClientsInput[]
    updateMany?: documentsUpdateManyWithWhereWithoutClientsInput | documentsUpdateManyWithWhereWithoutClientsInput[]
    deleteMany?: documentsScalarWhereInput | documentsScalarWhereInput[]
  }

  export type projectsUncheckedUpdateManyWithoutClientsNestedInput = {
    create?: XOR<projectsCreateWithoutClientsInput, projectsUncheckedCreateWithoutClientsInput> | projectsCreateWithoutClientsInput[] | projectsUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: projectsCreateOrConnectWithoutClientsInput | projectsCreateOrConnectWithoutClientsInput[]
    upsert?: projectsUpsertWithWhereUniqueWithoutClientsInput | projectsUpsertWithWhereUniqueWithoutClientsInput[]
    createMany?: projectsCreateManyClientsInputEnvelope
    set?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    disconnect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    delete?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    connect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    update?: projectsUpdateWithWhereUniqueWithoutClientsInput | projectsUpdateWithWhereUniqueWithoutClientsInput[]
    updateMany?: projectsUpdateManyWithWhereWithoutClientsInput | projectsUpdateManyWithWhereWithoutClientsInput[]
    deleteMany?: projectsScalarWhereInput | projectsScalarWhereInput[]
  }

  export type clientsCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<clientsCreateWithoutDocumentsInput, clientsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: clientsCreateOrConnectWithoutDocumentsInput
    connect?: clientsWhereUniqueInput
  }

  export type client_picsCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<client_picsCreateWithoutDocumentsInput, client_picsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: client_picsCreateOrConnectWithoutDocumentsInput
    connect?: client_picsWhereUniqueInput
  }

  export type projectsCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<projectsCreateWithoutDocumentsInput, projectsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: projectsCreateOrConnectWithoutDocumentsInput
    connect?: projectsWhereUniqueInput
  }

  export type NullableEnumdocument_typesFieldUpdateOperationsInput = {
    set?: $Enums.document_types | null
  }

  export type clientsUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<clientsCreateWithoutDocumentsInput, clientsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: clientsCreateOrConnectWithoutDocumentsInput
    upsert?: clientsUpsertWithoutDocumentsInput
    connect?: clientsWhereUniqueInput
    update?: XOR<XOR<clientsUpdateToOneWithWhereWithoutDocumentsInput, clientsUpdateWithoutDocumentsInput>, clientsUncheckedUpdateWithoutDocumentsInput>
  }

  export type client_picsUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<client_picsCreateWithoutDocumentsInput, client_picsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: client_picsCreateOrConnectWithoutDocumentsInput
    upsert?: client_picsUpsertWithoutDocumentsInput
    connect?: client_picsWhereUniqueInput
    update?: XOR<XOR<client_picsUpdateToOneWithWhereWithoutDocumentsInput, client_picsUpdateWithoutDocumentsInput>, client_picsUncheckedUpdateWithoutDocumentsInput>
  }

  export type projectsUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<projectsCreateWithoutDocumentsInput, projectsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: projectsCreateOrConnectWithoutDocumentsInput
    upsert?: projectsUpsertWithoutDocumentsInput
    connect?: projectsWhereUniqueInput
    update?: XOR<XOR<projectsUpdateToOneWithWhereWithoutDocumentsInput, projectsUpdateWithoutDocumentsInput>, projectsUncheckedUpdateWithoutDocumentsInput>
  }

  export type project_team_membersCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<project_team_membersCreateWithoutEmployeesInput, project_team_membersUncheckedCreateWithoutEmployeesInput> | project_team_membersCreateWithoutEmployeesInput[] | project_team_membersUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutEmployeesInput | project_team_membersCreateOrConnectWithoutEmployeesInput[]
    createMany?: project_team_membersCreateManyEmployeesInputEnvelope
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
  }

  export type project_teamsCreateNestedManyWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    create?: XOR<project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput> | project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput[] | project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    createMany?: project_teamsCreateManyEmployees_project_teams_auditor_idToemployeesInputEnvelope
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
  }

  export type project_teamsCreateNestedManyWithoutEmployees_project_teams_manager_idToemployeesInput = {
    create?: XOR<project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput> | project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput[] | project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput[]
    createMany?: project_teamsCreateManyEmployees_project_teams_manager_idToemployeesInputEnvelope
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
  }

  export type project_team_membersUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<project_team_membersCreateWithoutEmployeesInput, project_team_membersUncheckedCreateWithoutEmployeesInput> | project_team_membersCreateWithoutEmployeesInput[] | project_team_membersUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutEmployeesInput | project_team_membersCreateOrConnectWithoutEmployeesInput[]
    createMany?: project_team_membersCreateManyEmployeesInputEnvelope
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
  }

  export type project_teamsUncheckedCreateNestedManyWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    create?: XOR<project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput> | project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput[] | project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    createMany?: project_teamsCreateManyEmployees_project_teams_auditor_idToemployeesInputEnvelope
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
  }

  export type project_teamsUncheckedCreateNestedManyWithoutEmployees_project_teams_manager_idToemployeesInput = {
    create?: XOR<project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput> | project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput[] | project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput[]
    createMany?: project_teamsCreateManyEmployees_project_teams_manager_idToemployeesInputEnvelope
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
  }

  export type Enumstatus_employeesFieldUpdateOperationsInput = {
    set?: $Enums.status_employees
  }

  export type project_team_membersUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<project_team_membersCreateWithoutEmployeesInput, project_team_membersUncheckedCreateWithoutEmployeesInput> | project_team_membersCreateWithoutEmployeesInput[] | project_team_membersUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutEmployeesInput | project_team_membersCreateOrConnectWithoutEmployeesInput[]
    upsert?: project_team_membersUpsertWithWhereUniqueWithoutEmployeesInput | project_team_membersUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: project_team_membersCreateManyEmployeesInputEnvelope
    set?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    disconnect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    delete?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    update?: project_team_membersUpdateWithWhereUniqueWithoutEmployeesInput | project_team_membersUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: project_team_membersUpdateManyWithWhereWithoutEmployeesInput | project_team_membersUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: project_team_membersScalarWhereInput | project_team_membersScalarWhereInput[]
  }

  export type project_teamsUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesNestedInput = {
    create?: XOR<project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput> | project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput[] | project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    upsert?: project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    createMany?: project_teamsCreateManyEmployees_project_teams_auditor_idToemployeesInputEnvelope
    set?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    disconnect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    delete?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    update?: project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    updateMany?: project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    deleteMany?: project_teamsScalarWhereInput | project_teamsScalarWhereInput[]
  }

  export type project_teamsUpdateManyWithoutEmployees_project_teams_manager_idToemployeesNestedInput = {
    create?: XOR<project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput> | project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput[] | project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput[]
    upsert?: project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput[]
    createMany?: project_teamsCreateManyEmployees_project_teams_manager_idToemployeesInputEnvelope
    set?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    disconnect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    delete?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    update?: project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput[]
    updateMany?: project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_manager_idToemployeesInput[]
    deleteMany?: project_teamsScalarWhereInput | project_teamsScalarWhereInput[]
  }

  export type project_team_membersUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<project_team_membersCreateWithoutEmployeesInput, project_team_membersUncheckedCreateWithoutEmployeesInput> | project_team_membersCreateWithoutEmployeesInput[] | project_team_membersUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutEmployeesInput | project_team_membersCreateOrConnectWithoutEmployeesInput[]
    upsert?: project_team_membersUpsertWithWhereUniqueWithoutEmployeesInput | project_team_membersUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: project_team_membersCreateManyEmployeesInputEnvelope
    set?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    disconnect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    delete?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    update?: project_team_membersUpdateWithWhereUniqueWithoutEmployeesInput | project_team_membersUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: project_team_membersUpdateManyWithWhereWithoutEmployeesInput | project_team_membersUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: project_team_membersScalarWhereInput | project_team_membersScalarWhereInput[]
  }

  export type project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesNestedInput = {
    create?: XOR<project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput> | project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput[] | project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    upsert?: project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    createMany?: project_teamsCreateManyEmployees_project_teams_auditor_idToemployeesInputEnvelope
    set?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    disconnect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    delete?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    update?: project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    updateMany?: project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_auditor_idToemployeesInput | project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_auditor_idToemployeesInput[]
    deleteMany?: project_teamsScalarWhereInput | project_teamsScalarWhereInput[]
  }

  export type project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_manager_idToemployeesNestedInput = {
    create?: XOR<project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput> | project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput[] | project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput[]
    upsert?: project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput[]
    createMany?: project_teamsCreateManyEmployees_project_teams_manager_idToemployeesInputEnvelope
    set?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    disconnect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    delete?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    update?: project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput[]
    updateMany?: project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_manager_idToemployeesInput | project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_manager_idToemployeesInput[]
    deleteMany?: project_teamsScalarWhereInput | project_teamsScalarWhereInput[]
  }

  export type employeesCreateNestedOneWithoutProject_team_membersInput = {
    create?: XOR<employeesCreateWithoutProject_team_membersInput, employeesUncheckedCreateWithoutProject_team_membersInput>
    connectOrCreate?: employeesCreateOrConnectWithoutProject_team_membersInput
    connect?: employeesWhereUniqueInput
  }

  export type project_teamsCreateNestedOneWithoutProject_team_membersInput = {
    create?: XOR<project_teamsCreateWithoutProject_team_membersInput, project_teamsUncheckedCreateWithoutProject_team_membersInput>
    connectOrCreate?: project_teamsCreateOrConnectWithoutProject_team_membersInput
    connect?: project_teamsWhereUniqueInput
  }

  export type role_levelsCreateNestedOneWithoutProject_team_membersInput = {
    create?: XOR<role_levelsCreateWithoutProject_team_membersInput, role_levelsUncheckedCreateWithoutProject_team_membersInput>
    connectOrCreate?: role_levelsCreateOrConnectWithoutProject_team_membersInput
    connect?: role_levelsWhereUniqueInput
  }

  export type employeesUpdateOneRequiredWithoutProject_team_membersNestedInput = {
    create?: XOR<employeesCreateWithoutProject_team_membersInput, employeesUncheckedCreateWithoutProject_team_membersInput>
    connectOrCreate?: employeesCreateOrConnectWithoutProject_team_membersInput
    upsert?: employeesUpsertWithoutProject_team_membersInput
    connect?: employeesWhereUniqueInput
    update?: XOR<XOR<employeesUpdateToOneWithWhereWithoutProject_team_membersInput, employeesUpdateWithoutProject_team_membersInput>, employeesUncheckedUpdateWithoutProject_team_membersInput>
  }

  export type project_teamsUpdateOneRequiredWithoutProject_team_membersNestedInput = {
    create?: XOR<project_teamsCreateWithoutProject_team_membersInput, project_teamsUncheckedCreateWithoutProject_team_membersInput>
    connectOrCreate?: project_teamsCreateOrConnectWithoutProject_team_membersInput
    upsert?: project_teamsUpsertWithoutProject_team_membersInput
    connect?: project_teamsWhereUniqueInput
    update?: XOR<XOR<project_teamsUpdateToOneWithWhereWithoutProject_team_membersInput, project_teamsUpdateWithoutProject_team_membersInput>, project_teamsUncheckedUpdateWithoutProject_team_membersInput>
  }

  export type role_levelsUpdateOneRequiredWithoutProject_team_membersNestedInput = {
    create?: XOR<role_levelsCreateWithoutProject_team_membersInput, role_levelsUncheckedCreateWithoutProject_team_membersInput>
    connectOrCreate?: role_levelsCreateOrConnectWithoutProject_team_membersInput
    upsert?: role_levelsUpsertWithoutProject_team_membersInput
    connect?: role_levelsWhereUniqueInput
    update?: XOR<XOR<role_levelsUpdateToOneWithWhereWithoutProject_team_membersInput, role_levelsUpdateWithoutProject_team_membersInput>, role_levelsUncheckedUpdateWithoutProject_team_membersInput>
  }

  export type project_team_membersCreateNestedManyWithoutProject_teamsInput = {
    create?: XOR<project_team_membersCreateWithoutProject_teamsInput, project_team_membersUncheckedCreateWithoutProject_teamsInput> | project_team_membersCreateWithoutProject_teamsInput[] | project_team_membersUncheckedCreateWithoutProject_teamsInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutProject_teamsInput | project_team_membersCreateOrConnectWithoutProject_teamsInput[]
    createMany?: project_team_membersCreateManyProject_teamsInputEnvelope
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
  }

  export type employeesCreateNestedOneWithoutProject_teams_project_teams_auditor_idToemployeesInput = {
    create?: XOR<employeesCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput, employeesUncheckedCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutProject_teams_project_teams_auditor_idToemployeesInput
    connect?: employeesWhereUniqueInput
  }

  export type employeesCreateNestedOneWithoutProject_teams_project_teams_manager_idToemployeesInput = {
    create?: XOR<employeesCreateWithoutProject_teams_project_teams_manager_idToemployeesInput, employeesUncheckedCreateWithoutProject_teams_project_teams_manager_idToemployeesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutProject_teams_project_teams_manager_idToemployeesInput
    connect?: employeesWhereUniqueInput
  }

  export type projectsCreateNestedOneWithoutProject_teamsInput = {
    create?: XOR<projectsCreateWithoutProject_teamsInput, projectsUncheckedCreateWithoutProject_teamsInput>
    connectOrCreate?: projectsCreateOrConnectWithoutProject_teamsInput
    connect?: projectsWhereUniqueInput
  }

  export type project_team_membersUncheckedCreateNestedManyWithoutProject_teamsInput = {
    create?: XOR<project_team_membersCreateWithoutProject_teamsInput, project_team_membersUncheckedCreateWithoutProject_teamsInput> | project_team_membersCreateWithoutProject_teamsInput[] | project_team_membersUncheckedCreateWithoutProject_teamsInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutProject_teamsInput | project_team_membersCreateOrConnectWithoutProject_teamsInput[]
    createMany?: project_team_membersCreateManyProject_teamsInputEnvelope
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
  }

  export type project_team_membersUpdateManyWithoutProject_teamsNestedInput = {
    create?: XOR<project_team_membersCreateWithoutProject_teamsInput, project_team_membersUncheckedCreateWithoutProject_teamsInput> | project_team_membersCreateWithoutProject_teamsInput[] | project_team_membersUncheckedCreateWithoutProject_teamsInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutProject_teamsInput | project_team_membersCreateOrConnectWithoutProject_teamsInput[]
    upsert?: project_team_membersUpsertWithWhereUniqueWithoutProject_teamsInput | project_team_membersUpsertWithWhereUniqueWithoutProject_teamsInput[]
    createMany?: project_team_membersCreateManyProject_teamsInputEnvelope
    set?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    disconnect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    delete?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    update?: project_team_membersUpdateWithWhereUniqueWithoutProject_teamsInput | project_team_membersUpdateWithWhereUniqueWithoutProject_teamsInput[]
    updateMany?: project_team_membersUpdateManyWithWhereWithoutProject_teamsInput | project_team_membersUpdateManyWithWhereWithoutProject_teamsInput[]
    deleteMany?: project_team_membersScalarWhereInput | project_team_membersScalarWhereInput[]
  }

  export type employeesUpdateOneWithoutProject_teams_project_teams_auditor_idToemployeesNestedInput = {
    create?: XOR<employeesCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput, employeesUncheckedCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutProject_teams_project_teams_auditor_idToemployeesInput
    upsert?: employeesUpsertWithoutProject_teams_project_teams_auditor_idToemployeesInput
    disconnect?: employeesWhereInput | boolean
    delete?: employeesWhereInput | boolean
    connect?: employeesWhereUniqueInput
    update?: XOR<XOR<employeesUpdateToOneWithWhereWithoutProject_teams_project_teams_auditor_idToemployeesInput, employeesUpdateWithoutProject_teams_project_teams_auditor_idToemployeesInput>, employeesUncheckedUpdateWithoutProject_teams_project_teams_auditor_idToemployeesInput>
  }

  export type employeesUpdateOneRequiredWithoutProject_teams_project_teams_manager_idToemployeesNestedInput = {
    create?: XOR<employeesCreateWithoutProject_teams_project_teams_manager_idToemployeesInput, employeesUncheckedCreateWithoutProject_teams_project_teams_manager_idToemployeesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutProject_teams_project_teams_manager_idToemployeesInput
    upsert?: employeesUpsertWithoutProject_teams_project_teams_manager_idToemployeesInput
    connect?: employeesWhereUniqueInput
    update?: XOR<XOR<employeesUpdateToOneWithWhereWithoutProject_teams_project_teams_manager_idToemployeesInput, employeesUpdateWithoutProject_teams_project_teams_manager_idToemployeesInput>, employeesUncheckedUpdateWithoutProject_teams_project_teams_manager_idToemployeesInput>
  }

  export type projectsUpdateOneRequiredWithoutProject_teamsNestedInput = {
    create?: XOR<projectsCreateWithoutProject_teamsInput, projectsUncheckedCreateWithoutProject_teamsInput>
    connectOrCreate?: projectsCreateOrConnectWithoutProject_teamsInput
    upsert?: projectsUpsertWithoutProject_teamsInput
    connect?: projectsWhereUniqueInput
    update?: XOR<XOR<projectsUpdateToOneWithWhereWithoutProject_teamsInput, projectsUpdateWithoutProject_teamsInput>, projectsUncheckedUpdateWithoutProject_teamsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type project_team_membersUncheckedUpdateManyWithoutProject_teamsNestedInput = {
    create?: XOR<project_team_membersCreateWithoutProject_teamsInput, project_team_membersUncheckedCreateWithoutProject_teamsInput> | project_team_membersCreateWithoutProject_teamsInput[] | project_team_membersUncheckedCreateWithoutProject_teamsInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutProject_teamsInput | project_team_membersCreateOrConnectWithoutProject_teamsInput[]
    upsert?: project_team_membersUpsertWithWhereUniqueWithoutProject_teamsInput | project_team_membersUpsertWithWhereUniqueWithoutProject_teamsInput[]
    createMany?: project_team_membersCreateManyProject_teamsInputEnvelope
    set?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    disconnect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    delete?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    update?: project_team_membersUpdateWithWhereUniqueWithoutProject_teamsInput | project_team_membersUpdateWithWhereUniqueWithoutProject_teamsInput[]
    updateMany?: project_team_membersUpdateManyWithWhereWithoutProject_teamsInput | project_team_membersUpdateManyWithWhereWithoutProject_teamsInput[]
    deleteMany?: project_team_membersScalarWhereInput | project_team_membersScalarWhereInput[]
  }

  export type client_picsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<client_picsCreateWithoutProjectsInput, client_picsUncheckedCreateWithoutProjectsInput> | client_picsCreateWithoutProjectsInput[] | client_picsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: client_picsCreateOrConnectWithoutProjectsInput | client_picsCreateOrConnectWithoutProjectsInput[]
    createMany?: client_picsCreateManyProjectsInputEnvelope
    connect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
  }

  export type documentsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<documentsCreateWithoutProjectsInput, documentsUncheckedCreateWithoutProjectsInput> | documentsCreateWithoutProjectsInput[] | documentsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutProjectsInput | documentsCreateOrConnectWithoutProjectsInput[]
    createMany?: documentsCreateManyProjectsInputEnvelope
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
  }

  export type project_teamsCreateNestedManyWithoutProjectsInput = {
    create?: XOR<project_teamsCreateWithoutProjectsInput, project_teamsUncheckedCreateWithoutProjectsInput> | project_teamsCreateWithoutProjectsInput[] | project_teamsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutProjectsInput | project_teamsCreateOrConnectWithoutProjectsInput[]
    createMany?: project_teamsCreateManyProjectsInputEnvelope
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
  }

  export type clientsCreateNestedOneWithoutProjectsInput = {
    create?: XOR<clientsCreateWithoutProjectsInput, clientsUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: clientsCreateOrConnectWithoutProjectsInput
    connect?: clientsWhereUniqueInput
  }

  export type client_picsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<client_picsCreateWithoutProjectsInput, client_picsUncheckedCreateWithoutProjectsInput> | client_picsCreateWithoutProjectsInput[] | client_picsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: client_picsCreateOrConnectWithoutProjectsInput | client_picsCreateOrConnectWithoutProjectsInput[]
    createMany?: client_picsCreateManyProjectsInputEnvelope
    connect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
  }

  export type documentsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<documentsCreateWithoutProjectsInput, documentsUncheckedCreateWithoutProjectsInput> | documentsCreateWithoutProjectsInput[] | documentsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutProjectsInput | documentsCreateOrConnectWithoutProjectsInput[]
    createMany?: documentsCreateManyProjectsInputEnvelope
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
  }

  export type project_teamsUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<project_teamsCreateWithoutProjectsInput, project_teamsUncheckedCreateWithoutProjectsInput> | project_teamsCreateWithoutProjectsInput[] | project_teamsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutProjectsInput | project_teamsCreateOrConnectWithoutProjectsInput[]
    createMany?: project_teamsCreateManyProjectsInputEnvelope
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
  }

  export type Enumproject_typesFieldUpdateOperationsInput = {
    set?: $Enums.project_types
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type client_picsUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<client_picsCreateWithoutProjectsInput, client_picsUncheckedCreateWithoutProjectsInput> | client_picsCreateWithoutProjectsInput[] | client_picsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: client_picsCreateOrConnectWithoutProjectsInput | client_picsCreateOrConnectWithoutProjectsInput[]
    upsert?: client_picsUpsertWithWhereUniqueWithoutProjectsInput | client_picsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: client_picsCreateManyProjectsInputEnvelope
    set?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    disconnect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    delete?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    connect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    update?: client_picsUpdateWithWhereUniqueWithoutProjectsInput | client_picsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: client_picsUpdateManyWithWhereWithoutProjectsInput | client_picsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: client_picsScalarWhereInput | client_picsScalarWhereInput[]
  }

  export type documentsUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<documentsCreateWithoutProjectsInput, documentsUncheckedCreateWithoutProjectsInput> | documentsCreateWithoutProjectsInput[] | documentsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutProjectsInput | documentsCreateOrConnectWithoutProjectsInput[]
    upsert?: documentsUpsertWithWhereUniqueWithoutProjectsInput | documentsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: documentsCreateManyProjectsInputEnvelope
    set?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    disconnect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    delete?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    update?: documentsUpdateWithWhereUniqueWithoutProjectsInput | documentsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: documentsUpdateManyWithWhereWithoutProjectsInput | documentsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: documentsScalarWhereInput | documentsScalarWhereInput[]
  }

  export type project_teamsUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<project_teamsCreateWithoutProjectsInput, project_teamsUncheckedCreateWithoutProjectsInput> | project_teamsCreateWithoutProjectsInput[] | project_teamsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutProjectsInput | project_teamsCreateOrConnectWithoutProjectsInput[]
    upsert?: project_teamsUpsertWithWhereUniqueWithoutProjectsInput | project_teamsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: project_teamsCreateManyProjectsInputEnvelope
    set?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    disconnect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    delete?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    update?: project_teamsUpdateWithWhereUniqueWithoutProjectsInput | project_teamsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: project_teamsUpdateManyWithWhereWithoutProjectsInput | project_teamsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: project_teamsScalarWhereInput | project_teamsScalarWhereInput[]
  }

  export type clientsUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<clientsCreateWithoutProjectsInput, clientsUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: clientsCreateOrConnectWithoutProjectsInput
    upsert?: clientsUpsertWithoutProjectsInput
    connect?: clientsWhereUniqueInput
    update?: XOR<XOR<clientsUpdateToOneWithWhereWithoutProjectsInput, clientsUpdateWithoutProjectsInput>, clientsUncheckedUpdateWithoutProjectsInput>
  }

  export type client_picsUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<client_picsCreateWithoutProjectsInput, client_picsUncheckedCreateWithoutProjectsInput> | client_picsCreateWithoutProjectsInput[] | client_picsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: client_picsCreateOrConnectWithoutProjectsInput | client_picsCreateOrConnectWithoutProjectsInput[]
    upsert?: client_picsUpsertWithWhereUniqueWithoutProjectsInput | client_picsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: client_picsCreateManyProjectsInputEnvelope
    set?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    disconnect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    delete?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    connect?: client_picsWhereUniqueInput | client_picsWhereUniqueInput[]
    update?: client_picsUpdateWithWhereUniqueWithoutProjectsInput | client_picsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: client_picsUpdateManyWithWhereWithoutProjectsInput | client_picsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: client_picsScalarWhereInput | client_picsScalarWhereInput[]
  }

  export type documentsUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<documentsCreateWithoutProjectsInput, documentsUncheckedCreateWithoutProjectsInput> | documentsCreateWithoutProjectsInput[] | documentsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: documentsCreateOrConnectWithoutProjectsInput | documentsCreateOrConnectWithoutProjectsInput[]
    upsert?: documentsUpsertWithWhereUniqueWithoutProjectsInput | documentsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: documentsCreateManyProjectsInputEnvelope
    set?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    disconnect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    delete?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    connect?: documentsWhereUniqueInput | documentsWhereUniqueInput[]
    update?: documentsUpdateWithWhereUniqueWithoutProjectsInput | documentsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: documentsUpdateManyWithWhereWithoutProjectsInput | documentsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: documentsScalarWhereInput | documentsScalarWhereInput[]
  }

  export type project_teamsUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<project_teamsCreateWithoutProjectsInput, project_teamsUncheckedCreateWithoutProjectsInput> | project_teamsCreateWithoutProjectsInput[] | project_teamsUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: project_teamsCreateOrConnectWithoutProjectsInput | project_teamsCreateOrConnectWithoutProjectsInput[]
    upsert?: project_teamsUpsertWithWhereUniqueWithoutProjectsInput | project_teamsUpsertWithWhereUniqueWithoutProjectsInput[]
    createMany?: project_teamsCreateManyProjectsInputEnvelope
    set?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    disconnect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    delete?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    connect?: project_teamsWhereUniqueInput | project_teamsWhereUniqueInput[]
    update?: project_teamsUpdateWithWhereUniqueWithoutProjectsInput | project_teamsUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: project_teamsUpdateManyWithWhereWithoutProjectsInput | project_teamsUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: project_teamsScalarWhereInput | project_teamsScalarWhereInput[]
  }

  export type project_team_membersCreateNestedManyWithoutRole_levelsInput = {
    create?: XOR<project_team_membersCreateWithoutRole_levelsInput, project_team_membersUncheckedCreateWithoutRole_levelsInput> | project_team_membersCreateWithoutRole_levelsInput[] | project_team_membersUncheckedCreateWithoutRole_levelsInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutRole_levelsInput | project_team_membersCreateOrConnectWithoutRole_levelsInput[]
    createMany?: project_team_membersCreateManyRole_levelsInputEnvelope
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
  }

  export type project_team_membersUncheckedCreateNestedManyWithoutRole_levelsInput = {
    create?: XOR<project_team_membersCreateWithoutRole_levelsInput, project_team_membersUncheckedCreateWithoutRole_levelsInput> | project_team_membersCreateWithoutRole_levelsInput[] | project_team_membersUncheckedCreateWithoutRole_levelsInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutRole_levelsInput | project_team_membersCreateOrConnectWithoutRole_levelsInput[]
    createMany?: project_team_membersCreateManyRole_levelsInputEnvelope
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
  }

  export type project_team_membersUpdateManyWithoutRole_levelsNestedInput = {
    create?: XOR<project_team_membersCreateWithoutRole_levelsInput, project_team_membersUncheckedCreateWithoutRole_levelsInput> | project_team_membersCreateWithoutRole_levelsInput[] | project_team_membersUncheckedCreateWithoutRole_levelsInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutRole_levelsInput | project_team_membersCreateOrConnectWithoutRole_levelsInput[]
    upsert?: project_team_membersUpsertWithWhereUniqueWithoutRole_levelsInput | project_team_membersUpsertWithWhereUniqueWithoutRole_levelsInput[]
    createMany?: project_team_membersCreateManyRole_levelsInputEnvelope
    set?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    disconnect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    delete?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    update?: project_team_membersUpdateWithWhereUniqueWithoutRole_levelsInput | project_team_membersUpdateWithWhereUniqueWithoutRole_levelsInput[]
    updateMany?: project_team_membersUpdateManyWithWhereWithoutRole_levelsInput | project_team_membersUpdateManyWithWhereWithoutRole_levelsInput[]
    deleteMany?: project_team_membersScalarWhereInput | project_team_membersScalarWhereInput[]
  }

  export type project_team_membersUncheckedUpdateManyWithoutRole_levelsNestedInput = {
    create?: XOR<project_team_membersCreateWithoutRole_levelsInput, project_team_membersUncheckedCreateWithoutRole_levelsInput> | project_team_membersCreateWithoutRole_levelsInput[] | project_team_membersUncheckedCreateWithoutRole_levelsInput[]
    connectOrCreate?: project_team_membersCreateOrConnectWithoutRole_levelsInput | project_team_membersCreateOrConnectWithoutRole_levelsInput[]
    upsert?: project_team_membersUpsertWithWhereUniqueWithoutRole_levelsInput | project_team_membersUpsertWithWhereUniqueWithoutRole_levelsInput[]
    createMany?: project_team_membersCreateManyRole_levelsInputEnvelope
    set?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    disconnect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    delete?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    connect?: project_team_membersWhereUniqueInput | project_team_membersWhereUniqueInput[]
    update?: project_team_membersUpdateWithWhereUniqueWithoutRole_levelsInput | project_team_membersUpdateWithWhereUniqueWithoutRole_levelsInput[]
    updateMany?: project_team_membersUpdateManyWithWhereWithoutRole_levelsInput | project_team_membersUpdateManyWithWhereWithoutRole_levelsInput[]
    deleteMany?: project_team_membersScalarWhereInput | project_team_membersScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumdocument_typesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.document_types | Enumdocument_typesFieldRefInput<$PrismaModel> | null
    in?: $Enums.document_types[] | ListEnumdocument_typesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.document_types[] | ListEnumdocument_typesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumdocument_typesNullableFilter<$PrismaModel> | $Enums.document_types | null
  }

  export type NestedEnumdocument_typesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.document_types | Enumdocument_typesFieldRefInput<$PrismaModel> | null
    in?: $Enums.document_types[] | ListEnumdocument_typesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.document_types[] | ListEnumdocument_typesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumdocument_typesNullableWithAggregatesFilter<$PrismaModel> | $Enums.document_types | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumdocument_typesNullableFilter<$PrismaModel>
    _max?: NestedEnumdocument_typesNullableFilter<$PrismaModel>
  }

  export type NestedEnumstatus_employeesFilter<$PrismaModel = never> = {
    equals?: $Enums.status_employees | Enumstatus_employeesFieldRefInput<$PrismaModel>
    in?: $Enums.status_employees[] | ListEnumstatus_employeesFieldRefInput<$PrismaModel>
    notIn?: $Enums.status_employees[] | ListEnumstatus_employeesFieldRefInput<$PrismaModel>
    not?: NestedEnumstatus_employeesFilter<$PrismaModel> | $Enums.status_employees
  }

  export type NestedEnumstatus_employeesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.status_employees | Enumstatus_employeesFieldRefInput<$PrismaModel>
    in?: $Enums.status_employees[] | ListEnumstatus_employeesFieldRefInput<$PrismaModel>
    notIn?: $Enums.status_employees[] | ListEnumstatus_employeesFieldRefInput<$PrismaModel>
    not?: NestedEnumstatus_employeesWithAggregatesFilter<$PrismaModel> | $Enums.status_employees
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstatus_employeesFilter<$PrismaModel>
    _max?: NestedEnumstatus_employeesFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumproject_typesFilter<$PrismaModel = never> = {
    equals?: $Enums.project_types | Enumproject_typesFieldRefInput<$PrismaModel>
    in?: $Enums.project_types[] | ListEnumproject_typesFieldRefInput<$PrismaModel>
    notIn?: $Enums.project_types[] | ListEnumproject_typesFieldRefInput<$PrismaModel>
    not?: NestedEnumproject_typesFilter<$PrismaModel> | $Enums.project_types
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumproject_typesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.project_types | Enumproject_typesFieldRefInput<$PrismaModel>
    in?: $Enums.project_types[] | ListEnumproject_typesFieldRefInput<$PrismaModel>
    notIn?: $Enums.project_types[] | ListEnumproject_typesFieldRefInput<$PrismaModel>
    not?: NestedEnumproject_typesWithAggregatesFilter<$PrismaModel> | $Enums.project_types
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumproject_typesFilter<$PrismaModel>
    _max?: NestedEnumproject_typesFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type clientsCreateWithoutClient_picsInput = {
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    documents?: documentsCreateNestedManyWithoutClientsInput
    projects?: projectsCreateNestedManyWithoutClientsInput
  }

  export type clientsUncheckedCreateWithoutClient_picsInput = {
    id?: number
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    documents?: documentsUncheckedCreateNestedManyWithoutClientsInput
    projects?: projectsUncheckedCreateNestedManyWithoutClientsInput
  }

  export type clientsCreateOrConnectWithoutClient_picsInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutClient_picsInput, clientsUncheckedCreateWithoutClient_picsInput>
  }

  export type projectsCreateWithoutClient_picsInput = {
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    documents?: documentsCreateNestedManyWithoutProjectsInput
    project_teams?: project_teamsCreateNestedManyWithoutProjectsInput
    clients: clientsCreateNestedOneWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutClient_picsInput = {
    id?: number
    client_id: number
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    documents?: documentsUncheckedCreateNestedManyWithoutProjectsInput
    project_teams?: project_teamsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutClient_picsInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsCreateWithoutClient_picsInput, projectsUncheckedCreateWithoutClient_picsInput>
  }

  export type documentsCreateWithoutClient_picsInput = {
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    clients: clientsCreateNestedOneWithoutDocumentsInput
    projects: projectsCreateNestedOneWithoutDocumentsInput
  }

  export type documentsUncheckedCreateWithoutClient_picsInput = {
    id?: number
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    project_id: number
    client_id: number
  }

  export type documentsCreateOrConnectWithoutClient_picsInput = {
    where: documentsWhereUniqueInput
    create: XOR<documentsCreateWithoutClient_picsInput, documentsUncheckedCreateWithoutClient_picsInput>
  }

  export type documentsCreateManyClient_picsInputEnvelope = {
    data: documentsCreateManyClient_picsInput | documentsCreateManyClient_picsInput[]
    skipDuplicates?: boolean
  }

  export type clientsUpsertWithoutClient_picsInput = {
    update: XOR<clientsUpdateWithoutClient_picsInput, clientsUncheckedUpdateWithoutClient_picsInput>
    create: XOR<clientsCreateWithoutClient_picsInput, clientsUncheckedCreateWithoutClient_picsInput>
    where?: clientsWhereInput
  }

  export type clientsUpdateToOneWithWhereWithoutClient_picsInput = {
    where?: clientsWhereInput
    data: XOR<clientsUpdateWithoutClient_picsInput, clientsUncheckedUpdateWithoutClient_picsInput>
  }

  export type clientsUpdateWithoutClient_picsInput = {
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documents?: documentsUpdateManyWithoutClientsNestedInput
    projects?: projectsUpdateManyWithoutClientsNestedInput
  }

  export type clientsUncheckedUpdateWithoutClient_picsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documents?: documentsUncheckedUpdateManyWithoutClientsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutClientsNestedInput
  }

  export type projectsUpsertWithoutClient_picsInput = {
    update: XOR<projectsUpdateWithoutClient_picsInput, projectsUncheckedUpdateWithoutClient_picsInput>
    create: XOR<projectsCreateWithoutClient_picsInput, projectsUncheckedCreateWithoutClient_picsInput>
    where?: projectsWhereInput
  }

  export type projectsUpdateToOneWithWhereWithoutClient_picsInput = {
    where?: projectsWhereInput
    data: XOR<projectsUpdateWithoutClient_picsInput, projectsUncheckedUpdateWithoutClient_picsInput>
  }

  export type projectsUpdateWithoutClient_picsInput = {
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    documents?: documentsUpdateManyWithoutProjectsNestedInput
    project_teams?: project_teamsUpdateManyWithoutProjectsNestedInput
    clients?: clientsUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type projectsUncheckedUpdateWithoutClient_picsInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    documents?: documentsUncheckedUpdateManyWithoutProjectsNestedInput
    project_teams?: project_teamsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type documentsUpsertWithWhereUniqueWithoutClient_picsInput = {
    where: documentsWhereUniqueInput
    update: XOR<documentsUpdateWithoutClient_picsInput, documentsUncheckedUpdateWithoutClient_picsInput>
    create: XOR<documentsCreateWithoutClient_picsInput, documentsUncheckedCreateWithoutClient_picsInput>
  }

  export type documentsUpdateWithWhereUniqueWithoutClient_picsInput = {
    where: documentsWhereUniqueInput
    data: XOR<documentsUpdateWithoutClient_picsInput, documentsUncheckedUpdateWithoutClient_picsInput>
  }

  export type documentsUpdateManyWithWhereWithoutClient_picsInput = {
    where: documentsScalarWhereInput
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyWithoutClient_picsInput>
  }

  export type documentsScalarWhereInput = {
    AND?: documentsScalarWhereInput | documentsScalarWhereInput[]
    OR?: documentsScalarWhereInput[]
    NOT?: documentsScalarWhereInput | documentsScalarWhereInput[]
    id?: IntFilter<"documents"> | number
    document_types?: Enumdocument_typesNullableFilter<"documents"> | $Enums.document_types | null
    number?: StringFilter<"documents"> | string
    date_created?: DateTimeNullableFilter<"documents"> | Date | string | null
    date_signed?: DateTimeNullableFilter<"documents"> | Date | string | null
    document_url?: StringNullableFilter<"documents"> | string | null
    project_id?: IntFilter<"documents"> | number
    client_pic_id?: IntFilter<"documents"> | number
    client_id?: IntFilter<"documents"> | number
  }

  export type client_picsCreateWithoutClientsInput = {
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    projects: projectsCreateNestedOneWithoutClient_picsInput
    documents?: documentsCreateNestedManyWithoutClient_picsInput
  }

  export type client_picsUncheckedCreateWithoutClientsInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    project_id: number
    documents?: documentsUncheckedCreateNestedManyWithoutClient_picsInput
  }

  export type client_picsCreateOrConnectWithoutClientsInput = {
    where: client_picsWhereUniqueInput
    create: XOR<client_picsCreateWithoutClientsInput, client_picsUncheckedCreateWithoutClientsInput>
  }

  export type client_picsCreateManyClientsInputEnvelope = {
    data: client_picsCreateManyClientsInput | client_picsCreateManyClientsInput[]
    skipDuplicates?: boolean
  }

  export type documentsCreateWithoutClientsInput = {
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    client_pics: client_picsCreateNestedOneWithoutDocumentsInput
    projects: projectsCreateNestedOneWithoutDocumentsInput
  }

  export type documentsUncheckedCreateWithoutClientsInput = {
    id?: number
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    project_id: number
    client_pic_id: number
  }

  export type documentsCreateOrConnectWithoutClientsInput = {
    where: documentsWhereUniqueInput
    create: XOR<documentsCreateWithoutClientsInput, documentsUncheckedCreateWithoutClientsInput>
  }

  export type documentsCreateManyClientsInputEnvelope = {
    data: documentsCreateManyClientsInput | documentsCreateManyClientsInput[]
    skipDuplicates?: boolean
  }

  export type projectsCreateWithoutClientsInput = {
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    client_pics?: client_picsCreateNestedManyWithoutProjectsInput
    documents?: documentsCreateNestedManyWithoutProjectsInput
    project_teams?: project_teamsCreateNestedManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutClientsInput = {
    id?: number
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    client_pics?: client_picsUncheckedCreateNestedManyWithoutProjectsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjectsInput
    project_teams?: project_teamsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutClientsInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsCreateWithoutClientsInput, projectsUncheckedCreateWithoutClientsInput>
  }

  export type projectsCreateManyClientsInputEnvelope = {
    data: projectsCreateManyClientsInput | projectsCreateManyClientsInput[]
    skipDuplicates?: boolean
  }

  export type client_picsUpsertWithWhereUniqueWithoutClientsInput = {
    where: client_picsWhereUniqueInput
    update: XOR<client_picsUpdateWithoutClientsInput, client_picsUncheckedUpdateWithoutClientsInput>
    create: XOR<client_picsCreateWithoutClientsInput, client_picsUncheckedCreateWithoutClientsInput>
  }

  export type client_picsUpdateWithWhereUniqueWithoutClientsInput = {
    where: client_picsWhereUniqueInput
    data: XOR<client_picsUpdateWithoutClientsInput, client_picsUncheckedUpdateWithoutClientsInput>
  }

  export type client_picsUpdateManyWithWhereWithoutClientsInput = {
    where: client_picsScalarWhereInput
    data: XOR<client_picsUpdateManyMutationInput, client_picsUncheckedUpdateManyWithoutClientsInput>
  }

  export type client_picsScalarWhereInput = {
    AND?: client_picsScalarWhereInput | client_picsScalarWhereInput[]
    OR?: client_picsScalarWhereInput[]
    NOT?: client_picsScalarWhereInput | client_picsScalarWhereInput[]
    id?: IntFilter<"client_pics"> | number
    name?: StringFilter<"client_pics"> | string
    email?: StringNullableFilter<"client_pics"> | string | null
    phone?: StringNullableFilter<"client_pics"> | string | null
    title?: StringNullableFilter<"client_pics"> | string | null
    project_id?: IntFilter<"client_pics"> | number
    client_id?: IntFilter<"client_pics"> | number
  }

  export type documentsUpsertWithWhereUniqueWithoutClientsInput = {
    where: documentsWhereUniqueInput
    update: XOR<documentsUpdateWithoutClientsInput, documentsUncheckedUpdateWithoutClientsInput>
    create: XOR<documentsCreateWithoutClientsInput, documentsUncheckedCreateWithoutClientsInput>
  }

  export type documentsUpdateWithWhereUniqueWithoutClientsInput = {
    where: documentsWhereUniqueInput
    data: XOR<documentsUpdateWithoutClientsInput, documentsUncheckedUpdateWithoutClientsInput>
  }

  export type documentsUpdateManyWithWhereWithoutClientsInput = {
    where: documentsScalarWhereInput
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyWithoutClientsInput>
  }

  export type projectsUpsertWithWhereUniqueWithoutClientsInput = {
    where: projectsWhereUniqueInput
    update: XOR<projectsUpdateWithoutClientsInput, projectsUncheckedUpdateWithoutClientsInput>
    create: XOR<projectsCreateWithoutClientsInput, projectsUncheckedCreateWithoutClientsInput>
  }

  export type projectsUpdateWithWhereUniqueWithoutClientsInput = {
    where: projectsWhereUniqueInput
    data: XOR<projectsUpdateWithoutClientsInput, projectsUncheckedUpdateWithoutClientsInput>
  }

  export type projectsUpdateManyWithWhereWithoutClientsInput = {
    where: projectsScalarWhereInput
    data: XOR<projectsUpdateManyMutationInput, projectsUncheckedUpdateManyWithoutClientsInput>
  }

  export type projectsScalarWhereInput = {
    AND?: projectsScalarWhereInput | projectsScalarWhereInput[]
    OR?: projectsScalarWhereInput[]
    NOT?: projectsScalarWhereInput | projectsScalarWhereInput[]
    id?: IntFilter<"projects"> | number
    client_id?: IntFilter<"projects"> | number
    project_name?: StringFilter<"projects"> | string
    project_code?: StringFilter<"projects"> | string
    project_type?: Enumproject_typesFilter<"projects"> | $Enums.project_types
    contract_value?: DecimalNullableFilter<"projects"> | Decimal | DecimalJsLike | number | string | null
    started_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    finished_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"projects"> | Date | string | null
    is_deleted?: BoolNullableFilter<"projects"> | boolean | null
  }

  export type clientsCreateWithoutDocumentsInput = {
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    client_pics?: client_picsCreateNestedManyWithoutClientsInput
    projects?: projectsCreateNestedManyWithoutClientsInput
  }

  export type clientsUncheckedCreateWithoutDocumentsInput = {
    id?: number
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    client_pics?: client_picsUncheckedCreateNestedManyWithoutClientsInput
    projects?: projectsUncheckedCreateNestedManyWithoutClientsInput
  }

  export type clientsCreateOrConnectWithoutDocumentsInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutDocumentsInput, clientsUncheckedCreateWithoutDocumentsInput>
  }

  export type client_picsCreateWithoutDocumentsInput = {
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    clients: clientsCreateNestedOneWithoutClient_picsInput
    projects: projectsCreateNestedOneWithoutClient_picsInput
  }

  export type client_picsUncheckedCreateWithoutDocumentsInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    project_id: number
    client_id: number
  }

  export type client_picsCreateOrConnectWithoutDocumentsInput = {
    where: client_picsWhereUniqueInput
    create: XOR<client_picsCreateWithoutDocumentsInput, client_picsUncheckedCreateWithoutDocumentsInput>
  }

  export type projectsCreateWithoutDocumentsInput = {
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    client_pics?: client_picsCreateNestedManyWithoutProjectsInput
    project_teams?: project_teamsCreateNestedManyWithoutProjectsInput
    clients: clientsCreateNestedOneWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutDocumentsInput = {
    id?: number
    client_id: number
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    client_pics?: client_picsUncheckedCreateNestedManyWithoutProjectsInput
    project_teams?: project_teamsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutDocumentsInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsCreateWithoutDocumentsInput, projectsUncheckedCreateWithoutDocumentsInput>
  }

  export type clientsUpsertWithoutDocumentsInput = {
    update: XOR<clientsUpdateWithoutDocumentsInput, clientsUncheckedUpdateWithoutDocumentsInput>
    create: XOR<clientsCreateWithoutDocumentsInput, clientsUncheckedCreateWithoutDocumentsInput>
    where?: clientsWhereInput
  }

  export type clientsUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: clientsWhereInput
    data: XOR<clientsUpdateWithoutDocumentsInput, clientsUncheckedUpdateWithoutDocumentsInput>
  }

  export type clientsUpdateWithoutDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client_pics?: client_picsUpdateManyWithoutClientsNestedInput
    projects?: projectsUpdateManyWithoutClientsNestedInput
  }

  export type clientsUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client_pics?: client_picsUncheckedUpdateManyWithoutClientsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutClientsNestedInput
  }

  export type client_picsUpsertWithoutDocumentsInput = {
    update: XOR<client_picsUpdateWithoutDocumentsInput, client_picsUncheckedUpdateWithoutDocumentsInput>
    create: XOR<client_picsCreateWithoutDocumentsInput, client_picsUncheckedCreateWithoutDocumentsInput>
    where?: client_picsWhereInput
  }

  export type client_picsUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: client_picsWhereInput
    data: XOR<client_picsUpdateWithoutDocumentsInput, client_picsUncheckedUpdateWithoutDocumentsInput>
  }

  export type client_picsUpdateWithoutDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: clientsUpdateOneRequiredWithoutClient_picsNestedInput
    projects?: projectsUpdateOneRequiredWithoutClient_picsNestedInput
  }

  export type client_picsUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type projectsUpsertWithoutDocumentsInput = {
    update: XOR<projectsUpdateWithoutDocumentsInput, projectsUncheckedUpdateWithoutDocumentsInput>
    create: XOR<projectsCreateWithoutDocumentsInput, projectsUncheckedCreateWithoutDocumentsInput>
    where?: projectsWhereInput
  }

  export type projectsUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: projectsWhereInput
    data: XOR<projectsUpdateWithoutDocumentsInput, projectsUncheckedUpdateWithoutDocumentsInput>
  }

  export type projectsUpdateWithoutDocumentsInput = {
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_pics?: client_picsUpdateManyWithoutProjectsNestedInput
    project_teams?: project_teamsUpdateManyWithoutProjectsNestedInput
    clients?: clientsUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type projectsUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_pics?: client_picsUncheckedUpdateManyWithoutProjectsNestedInput
    project_teams?: project_teamsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type project_team_membersCreateWithoutEmployeesInput = {
    job_description?: string | null
    end_at?: Date | string | null
    project_teams: project_teamsCreateNestedOneWithoutProject_team_membersInput
    role_levels: role_levelsCreateNestedOneWithoutProject_team_membersInput
  }

  export type project_team_membersUncheckedCreateWithoutEmployeesInput = {
    id?: number
    role_id: number
    project_teams_id: number
    job_description?: string | null
    end_at?: Date | string | null
  }

  export type project_team_membersCreateOrConnectWithoutEmployeesInput = {
    where: project_team_membersWhereUniqueInput
    create: XOR<project_team_membersCreateWithoutEmployeesInput, project_team_membersUncheckedCreateWithoutEmployeesInput>
  }

  export type project_team_membersCreateManyEmployeesInputEnvelope = {
    data: project_team_membersCreateManyEmployeesInput | project_team_membersCreateManyEmployeesInput[]
    skipDuplicates?: boolean
  }

  export type project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    project_teams_name: string
    project_teams_email: string
    project_team_members?: project_team_membersCreateNestedManyWithoutProject_teamsInput
    employees_project_teams_manager_idToemployees: employeesCreateNestedOneWithoutProject_teams_project_teams_manager_idToemployeesInput
    projects: projectsCreateNestedOneWithoutProject_teamsInput
  }

  export type project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    manager_id: number
    project_id: number
    project_team_members?: project_team_membersUncheckedCreateNestedManyWithoutProject_teamsInput
  }

  export type project_teamsCreateOrConnectWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    where: project_teamsWhereUniqueInput
    create: XOR<project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput>
  }

  export type project_teamsCreateManyEmployees_project_teams_auditor_idToemployeesInputEnvelope = {
    data: project_teamsCreateManyEmployees_project_teams_auditor_idToemployeesInput | project_teamsCreateManyEmployees_project_teams_auditor_idToemployeesInput[]
    skipDuplicates?: boolean
  }

  export type project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput = {
    project_teams_name: string
    project_teams_email: string
    project_team_members?: project_team_membersCreateNestedManyWithoutProject_teamsInput
    employees_project_teams_auditor_idToemployees?: employeesCreateNestedOneWithoutProject_teams_project_teams_auditor_idToemployeesInput
    projects: projectsCreateNestedOneWithoutProject_teamsInput
  }

  export type project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    auditor_id?: number | null
    project_id: number
    project_team_members?: project_team_membersUncheckedCreateNestedManyWithoutProject_teamsInput
  }

  export type project_teamsCreateOrConnectWithoutEmployees_project_teams_manager_idToemployeesInput = {
    where: project_teamsWhereUniqueInput
    create: XOR<project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput>
  }

  export type project_teamsCreateManyEmployees_project_teams_manager_idToemployeesInputEnvelope = {
    data: project_teamsCreateManyEmployees_project_teams_manager_idToemployeesInput | project_teamsCreateManyEmployees_project_teams_manager_idToemployeesInput[]
    skipDuplicates?: boolean
  }

  export type project_team_membersUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: project_team_membersWhereUniqueInput
    update: XOR<project_team_membersUpdateWithoutEmployeesInput, project_team_membersUncheckedUpdateWithoutEmployeesInput>
    create: XOR<project_team_membersCreateWithoutEmployeesInput, project_team_membersUncheckedCreateWithoutEmployeesInput>
  }

  export type project_team_membersUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: project_team_membersWhereUniqueInput
    data: XOR<project_team_membersUpdateWithoutEmployeesInput, project_team_membersUncheckedUpdateWithoutEmployeesInput>
  }

  export type project_team_membersUpdateManyWithWhereWithoutEmployeesInput = {
    where: project_team_membersScalarWhereInput
    data: XOR<project_team_membersUpdateManyMutationInput, project_team_membersUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type project_team_membersScalarWhereInput = {
    AND?: project_team_membersScalarWhereInput | project_team_membersScalarWhereInput[]
    OR?: project_team_membersScalarWhereInput[]
    NOT?: project_team_membersScalarWhereInput | project_team_membersScalarWhereInput[]
    id?: IntFilter<"project_team_members"> | number
    role_id?: IntFilter<"project_team_members"> | number
    project_teams_id?: IntFilter<"project_team_members"> | number
    job_description?: StringNullableFilter<"project_team_members"> | string | null
    end_at?: DateTimeNullableFilter<"project_team_members"> | Date | string | null
    employee_id?: IntFilter<"project_team_members"> | number
  }

  export type project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    where: project_teamsWhereUniqueInput
    update: XOR<project_teamsUpdateWithoutEmployees_project_teams_auditor_idToemployeesInput, project_teamsUncheckedUpdateWithoutEmployees_project_teams_auditor_idToemployeesInput>
    create: XOR<project_teamsCreateWithoutEmployees_project_teams_auditor_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_auditor_idToemployeesInput>
  }

  export type project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    where: project_teamsWhereUniqueInput
    data: XOR<project_teamsUpdateWithoutEmployees_project_teams_auditor_idToemployeesInput, project_teamsUncheckedUpdateWithoutEmployees_project_teams_auditor_idToemployeesInput>
  }

  export type project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    where: project_teamsScalarWhereInput
    data: XOR<project_teamsUpdateManyMutationInput, project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesInput>
  }

  export type project_teamsScalarWhereInput = {
    AND?: project_teamsScalarWhereInput | project_teamsScalarWhereInput[]
    OR?: project_teamsScalarWhereInput[]
    NOT?: project_teamsScalarWhereInput | project_teamsScalarWhereInput[]
    id?: IntFilter<"project_teams"> | number
    project_teams_name?: StringFilter<"project_teams"> | string
    project_teams_email?: StringFilter<"project_teams"> | string
    manager_id?: IntFilter<"project_teams"> | number
    auditor_id?: IntNullableFilter<"project_teams"> | number | null
    project_id?: IntFilter<"project_teams"> | number
  }

  export type project_teamsUpsertWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput = {
    where: project_teamsWhereUniqueInput
    update: XOR<project_teamsUpdateWithoutEmployees_project_teams_manager_idToemployeesInput, project_teamsUncheckedUpdateWithoutEmployees_project_teams_manager_idToemployeesInput>
    create: XOR<project_teamsCreateWithoutEmployees_project_teams_manager_idToemployeesInput, project_teamsUncheckedCreateWithoutEmployees_project_teams_manager_idToemployeesInput>
  }

  export type project_teamsUpdateWithWhereUniqueWithoutEmployees_project_teams_manager_idToemployeesInput = {
    where: project_teamsWhereUniqueInput
    data: XOR<project_teamsUpdateWithoutEmployees_project_teams_manager_idToemployeesInput, project_teamsUncheckedUpdateWithoutEmployees_project_teams_manager_idToemployeesInput>
  }

  export type project_teamsUpdateManyWithWhereWithoutEmployees_project_teams_manager_idToemployeesInput = {
    where: project_teamsScalarWhereInput
    data: XOR<project_teamsUpdateManyMutationInput, project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_manager_idToemployeesInput>
  }

  export type employeesCreateWithoutProject_team_membersInput = {
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
    project_teams_project_teams_auditor_idToemployees?: project_teamsCreateNestedManyWithoutEmployees_project_teams_auditor_idToemployeesInput
    project_teams_project_teams_manager_idToemployees?: project_teamsCreateNestedManyWithoutEmployees_project_teams_manager_idToemployeesInput
  }

  export type employeesUncheckedCreateWithoutProject_team_membersInput = {
    id?: number
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
    project_teams_project_teams_auditor_idToemployees?: project_teamsUncheckedCreateNestedManyWithoutEmployees_project_teams_auditor_idToemployeesInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUncheckedCreateNestedManyWithoutEmployees_project_teams_manager_idToemployeesInput
  }

  export type employeesCreateOrConnectWithoutProject_team_membersInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutProject_team_membersInput, employeesUncheckedCreateWithoutProject_team_membersInput>
  }

  export type project_teamsCreateWithoutProject_team_membersInput = {
    project_teams_name: string
    project_teams_email: string
    employees_project_teams_auditor_idToemployees?: employeesCreateNestedOneWithoutProject_teams_project_teams_auditor_idToemployeesInput
    employees_project_teams_manager_idToemployees: employeesCreateNestedOneWithoutProject_teams_project_teams_manager_idToemployeesInput
    projects: projectsCreateNestedOneWithoutProject_teamsInput
  }

  export type project_teamsUncheckedCreateWithoutProject_team_membersInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    manager_id: number
    auditor_id?: number | null
    project_id: number
  }

  export type project_teamsCreateOrConnectWithoutProject_team_membersInput = {
    where: project_teamsWhereUniqueInput
    create: XOR<project_teamsCreateWithoutProject_team_membersInput, project_teamsUncheckedCreateWithoutProject_team_membersInput>
  }

  export type role_levelsCreateWithoutProject_team_membersInput = {
    role_name?: string | null
    role_level?: number | null
    role_price?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
  }

  export type role_levelsUncheckedCreateWithoutProject_team_membersInput = {
    id?: number
    role_name?: string | null
    role_level?: number | null
    role_price?: Decimal | DecimalJsLike | number | string | null
    is_default?: boolean | null
  }

  export type role_levelsCreateOrConnectWithoutProject_team_membersInput = {
    where: role_levelsWhereUniqueInput
    create: XOR<role_levelsCreateWithoutProject_team_membersInput, role_levelsUncheckedCreateWithoutProject_team_membersInput>
  }

  export type employeesUpsertWithoutProject_team_membersInput = {
    update: XOR<employeesUpdateWithoutProject_team_membersInput, employeesUncheckedUpdateWithoutProject_team_membersInput>
    create: XOR<employeesCreateWithoutProject_team_membersInput, employeesUncheckedCreateWithoutProject_team_membersInput>
    where?: employeesWhereInput
  }

  export type employeesUpdateToOneWithWhereWithoutProject_team_membersInput = {
    where?: employeesWhereInput
    data: XOR<employeesUpdateWithoutProject_team_membersInput, employeesUncheckedUpdateWithoutProject_team_membersInput>
  }

  export type employeesUpdateWithoutProject_team_membersInput = {
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    project_teams_project_teams_auditor_idToemployees?: project_teamsUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesNestedInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUpdateManyWithoutEmployees_project_teams_manager_idToemployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutProject_team_membersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    project_teams_project_teams_auditor_idToemployees?: project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesNestedInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_manager_idToemployeesNestedInput
  }

  export type project_teamsUpsertWithoutProject_team_membersInput = {
    update: XOR<project_teamsUpdateWithoutProject_team_membersInput, project_teamsUncheckedUpdateWithoutProject_team_membersInput>
    create: XOR<project_teamsCreateWithoutProject_team_membersInput, project_teamsUncheckedCreateWithoutProject_team_membersInput>
    where?: project_teamsWhereInput
  }

  export type project_teamsUpdateToOneWithWhereWithoutProject_team_membersInput = {
    where?: project_teamsWhereInput
    data: XOR<project_teamsUpdateWithoutProject_team_membersInput, project_teamsUncheckedUpdateWithoutProject_team_membersInput>
  }

  export type project_teamsUpdateWithoutProject_team_membersInput = {
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    employees_project_teams_auditor_idToemployees?: employeesUpdateOneWithoutProject_teams_project_teams_auditor_idToemployeesNestedInput
    employees_project_teams_manager_idToemployees?: employeesUpdateOneRequiredWithoutProject_teams_project_teams_manager_idToemployeesNestedInput
    projects?: projectsUpdateOneRequiredWithoutProject_teamsNestedInput
  }

  export type project_teamsUncheckedUpdateWithoutProject_team_membersInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    manager_id?: IntFieldUpdateOperationsInput | number
    auditor_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: IntFieldUpdateOperationsInput | number
  }

  export type role_levelsUpsertWithoutProject_team_membersInput = {
    update: XOR<role_levelsUpdateWithoutProject_team_membersInput, role_levelsUncheckedUpdateWithoutProject_team_membersInput>
    create: XOR<role_levelsCreateWithoutProject_team_membersInput, role_levelsUncheckedCreateWithoutProject_team_membersInput>
    where?: role_levelsWhereInput
  }

  export type role_levelsUpdateToOneWithWhereWithoutProject_team_membersInput = {
    where?: role_levelsWhereInput
    data: XOR<role_levelsUpdateWithoutProject_team_membersInput, role_levelsUncheckedUpdateWithoutProject_team_membersInput>
  }

  export type role_levelsUpdateWithoutProject_team_membersInput = {
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_level?: NullableIntFieldUpdateOperationsInput | number | null
    role_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type role_levelsUncheckedUpdateWithoutProject_team_membersInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_level?: NullableIntFieldUpdateOperationsInput | number | null
    role_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_default?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type project_team_membersCreateWithoutProject_teamsInput = {
    job_description?: string | null
    end_at?: Date | string | null
    employees: employeesCreateNestedOneWithoutProject_team_membersInput
    role_levels: role_levelsCreateNestedOneWithoutProject_team_membersInput
  }

  export type project_team_membersUncheckedCreateWithoutProject_teamsInput = {
    id?: number
    role_id: number
    job_description?: string | null
    end_at?: Date | string | null
    employee_id: number
  }

  export type project_team_membersCreateOrConnectWithoutProject_teamsInput = {
    where: project_team_membersWhereUniqueInput
    create: XOR<project_team_membersCreateWithoutProject_teamsInput, project_team_membersUncheckedCreateWithoutProject_teamsInput>
  }

  export type project_team_membersCreateManyProject_teamsInputEnvelope = {
    data: project_team_membersCreateManyProject_teamsInput | project_team_membersCreateManyProject_teamsInput[]
    skipDuplicates?: boolean
  }

  export type employeesCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput = {
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
    project_team_members?: project_team_membersCreateNestedManyWithoutEmployeesInput
    project_teams_project_teams_manager_idToemployees?: project_teamsCreateNestedManyWithoutEmployees_project_teams_manager_idToemployeesInput
  }

  export type employeesUncheckedCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput = {
    id?: number
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
    project_team_members?: project_team_membersUncheckedCreateNestedManyWithoutEmployeesInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUncheckedCreateNestedManyWithoutEmployees_project_teams_manager_idToemployeesInput
  }

  export type employeesCreateOrConnectWithoutProject_teams_project_teams_auditor_idToemployeesInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput, employeesUncheckedCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput>
  }

  export type employeesCreateWithoutProject_teams_project_teams_manager_idToemployeesInput = {
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
    project_team_members?: project_team_membersCreateNestedManyWithoutEmployeesInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsCreateNestedManyWithoutEmployees_project_teams_auditor_idToemployeesInput
  }

  export type employeesUncheckedCreateWithoutProject_teams_project_teams_manager_idToemployeesInput = {
    id?: number
    nik: string
    nip: string
    name: string
    email: string
    phone: string
    address: string
    position: string
    status: $Enums.status_employees
    password?: string | null
    refresh_token?: string | null
    project_team_members?: project_team_membersUncheckedCreateNestedManyWithoutEmployeesInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsUncheckedCreateNestedManyWithoutEmployees_project_teams_auditor_idToemployeesInput
  }

  export type employeesCreateOrConnectWithoutProject_teams_project_teams_manager_idToemployeesInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutProject_teams_project_teams_manager_idToemployeesInput, employeesUncheckedCreateWithoutProject_teams_project_teams_manager_idToemployeesInput>
  }

  export type projectsCreateWithoutProject_teamsInput = {
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    client_pics?: client_picsCreateNestedManyWithoutProjectsInput
    documents?: documentsCreateNestedManyWithoutProjectsInput
    clients: clientsCreateNestedOneWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutProject_teamsInput = {
    id?: number
    client_id: number
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
    client_pics?: client_picsUncheckedCreateNestedManyWithoutProjectsInput
    documents?: documentsUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutProject_teamsInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsCreateWithoutProject_teamsInput, projectsUncheckedCreateWithoutProject_teamsInput>
  }

  export type project_team_membersUpsertWithWhereUniqueWithoutProject_teamsInput = {
    where: project_team_membersWhereUniqueInput
    update: XOR<project_team_membersUpdateWithoutProject_teamsInput, project_team_membersUncheckedUpdateWithoutProject_teamsInput>
    create: XOR<project_team_membersCreateWithoutProject_teamsInput, project_team_membersUncheckedCreateWithoutProject_teamsInput>
  }

  export type project_team_membersUpdateWithWhereUniqueWithoutProject_teamsInput = {
    where: project_team_membersWhereUniqueInput
    data: XOR<project_team_membersUpdateWithoutProject_teamsInput, project_team_membersUncheckedUpdateWithoutProject_teamsInput>
  }

  export type project_team_membersUpdateManyWithWhereWithoutProject_teamsInput = {
    where: project_team_membersScalarWhereInput
    data: XOR<project_team_membersUpdateManyMutationInput, project_team_membersUncheckedUpdateManyWithoutProject_teamsInput>
  }

  export type employeesUpsertWithoutProject_teams_project_teams_auditor_idToemployeesInput = {
    update: XOR<employeesUpdateWithoutProject_teams_project_teams_auditor_idToemployeesInput, employeesUncheckedUpdateWithoutProject_teams_project_teams_auditor_idToemployeesInput>
    create: XOR<employeesCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput, employeesUncheckedCreateWithoutProject_teams_project_teams_auditor_idToemployeesInput>
    where?: employeesWhereInput
  }

  export type employeesUpdateToOneWithWhereWithoutProject_teams_project_teams_auditor_idToemployeesInput = {
    where?: employeesWhereInput
    data: XOR<employeesUpdateWithoutProject_teams_project_teams_auditor_idToemployeesInput, employeesUncheckedUpdateWithoutProject_teams_project_teams_auditor_idToemployeesInput>
  }

  export type employeesUpdateWithoutProject_teams_project_teams_auditor_idToemployeesInput = {
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    project_team_members?: project_team_membersUpdateManyWithoutEmployeesNestedInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUpdateManyWithoutEmployees_project_teams_manager_idToemployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutProject_teams_project_teams_auditor_idToemployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    project_team_members?: project_team_membersUncheckedUpdateManyWithoutEmployeesNestedInput
    project_teams_project_teams_manager_idToemployees?: project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_manager_idToemployeesNestedInput
  }

  export type employeesUpsertWithoutProject_teams_project_teams_manager_idToemployeesInput = {
    update: XOR<employeesUpdateWithoutProject_teams_project_teams_manager_idToemployeesInput, employeesUncheckedUpdateWithoutProject_teams_project_teams_manager_idToemployeesInput>
    create: XOR<employeesCreateWithoutProject_teams_project_teams_manager_idToemployeesInput, employeesUncheckedCreateWithoutProject_teams_project_teams_manager_idToemployeesInput>
    where?: employeesWhereInput
  }

  export type employeesUpdateToOneWithWhereWithoutProject_teams_project_teams_manager_idToemployeesInput = {
    where?: employeesWhereInput
    data: XOR<employeesUpdateWithoutProject_teams_project_teams_manager_idToemployeesInput, employeesUncheckedUpdateWithoutProject_teams_project_teams_manager_idToemployeesInput>
  }

  export type employeesUpdateWithoutProject_teams_project_teams_manager_idToemployeesInput = {
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    project_team_members?: project_team_membersUpdateManyWithoutEmployeesNestedInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutProject_teams_project_teams_manager_idToemployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nik?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: Enumstatus_employeesFieldUpdateOperationsInput | $Enums.status_employees
    password?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    project_team_members?: project_team_membersUncheckedUpdateManyWithoutEmployeesNestedInput
    project_teams_project_teams_auditor_idToemployees?: project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesNestedInput
  }

  export type projectsUpsertWithoutProject_teamsInput = {
    update: XOR<projectsUpdateWithoutProject_teamsInput, projectsUncheckedUpdateWithoutProject_teamsInput>
    create: XOR<projectsCreateWithoutProject_teamsInput, projectsUncheckedCreateWithoutProject_teamsInput>
    where?: projectsWhereInput
  }

  export type projectsUpdateToOneWithWhereWithoutProject_teamsInput = {
    where?: projectsWhereInput
    data: XOR<projectsUpdateWithoutProject_teamsInput, projectsUncheckedUpdateWithoutProject_teamsInput>
  }

  export type projectsUpdateWithoutProject_teamsInput = {
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_pics?: client_picsUpdateManyWithoutProjectsNestedInput
    documents?: documentsUpdateManyWithoutProjectsNestedInput
    clients?: clientsUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type projectsUncheckedUpdateWithoutProject_teamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_pics?: client_picsUncheckedUpdateManyWithoutProjectsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type client_picsCreateWithoutProjectsInput = {
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    clients: clientsCreateNestedOneWithoutClient_picsInput
    documents?: documentsCreateNestedManyWithoutClient_picsInput
  }

  export type client_picsUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    client_id: number
    documents?: documentsUncheckedCreateNestedManyWithoutClient_picsInput
  }

  export type client_picsCreateOrConnectWithoutProjectsInput = {
    where: client_picsWhereUniqueInput
    create: XOR<client_picsCreateWithoutProjectsInput, client_picsUncheckedCreateWithoutProjectsInput>
  }

  export type client_picsCreateManyProjectsInputEnvelope = {
    data: client_picsCreateManyProjectsInput | client_picsCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type documentsCreateWithoutProjectsInput = {
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    clients: clientsCreateNestedOneWithoutDocumentsInput
    client_pics: client_picsCreateNestedOneWithoutDocumentsInput
  }

  export type documentsUncheckedCreateWithoutProjectsInput = {
    id?: number
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    client_pic_id: number
    client_id: number
  }

  export type documentsCreateOrConnectWithoutProjectsInput = {
    where: documentsWhereUniqueInput
    create: XOR<documentsCreateWithoutProjectsInput, documentsUncheckedCreateWithoutProjectsInput>
  }

  export type documentsCreateManyProjectsInputEnvelope = {
    data: documentsCreateManyProjectsInput | documentsCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type project_teamsCreateWithoutProjectsInput = {
    project_teams_name: string
    project_teams_email: string
    project_team_members?: project_team_membersCreateNestedManyWithoutProject_teamsInput
    employees_project_teams_auditor_idToemployees?: employeesCreateNestedOneWithoutProject_teams_project_teams_auditor_idToemployeesInput
    employees_project_teams_manager_idToemployees: employeesCreateNestedOneWithoutProject_teams_project_teams_manager_idToemployeesInput
  }

  export type project_teamsUncheckedCreateWithoutProjectsInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    manager_id: number
    auditor_id?: number | null
    project_team_members?: project_team_membersUncheckedCreateNestedManyWithoutProject_teamsInput
  }

  export type project_teamsCreateOrConnectWithoutProjectsInput = {
    where: project_teamsWhereUniqueInput
    create: XOR<project_teamsCreateWithoutProjectsInput, project_teamsUncheckedCreateWithoutProjectsInput>
  }

  export type project_teamsCreateManyProjectsInputEnvelope = {
    data: project_teamsCreateManyProjectsInput | project_teamsCreateManyProjectsInput[]
    skipDuplicates?: boolean
  }

  export type clientsCreateWithoutProjectsInput = {
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    client_pics?: client_picsCreateNestedManyWithoutClientsInput
    documents?: documentsCreateNestedManyWithoutClientsInput
  }

  export type clientsUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    masked_description?: string | null
    address?: string | null
    phone?: string | null
    npwp?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    client_pics?: client_picsUncheckedCreateNestedManyWithoutClientsInput
    documents?: documentsUncheckedCreateNestedManyWithoutClientsInput
  }

  export type clientsCreateOrConnectWithoutProjectsInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutProjectsInput, clientsUncheckedCreateWithoutProjectsInput>
  }

  export type client_picsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: client_picsWhereUniqueInput
    update: XOR<client_picsUpdateWithoutProjectsInput, client_picsUncheckedUpdateWithoutProjectsInput>
    create: XOR<client_picsCreateWithoutProjectsInput, client_picsUncheckedCreateWithoutProjectsInput>
  }

  export type client_picsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: client_picsWhereUniqueInput
    data: XOR<client_picsUpdateWithoutProjectsInput, client_picsUncheckedUpdateWithoutProjectsInput>
  }

  export type client_picsUpdateManyWithWhereWithoutProjectsInput = {
    where: client_picsScalarWhereInput
    data: XOR<client_picsUpdateManyMutationInput, client_picsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type documentsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: documentsWhereUniqueInput
    update: XOR<documentsUpdateWithoutProjectsInput, documentsUncheckedUpdateWithoutProjectsInput>
    create: XOR<documentsCreateWithoutProjectsInput, documentsUncheckedCreateWithoutProjectsInput>
  }

  export type documentsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: documentsWhereUniqueInput
    data: XOR<documentsUpdateWithoutProjectsInput, documentsUncheckedUpdateWithoutProjectsInput>
  }

  export type documentsUpdateManyWithWhereWithoutProjectsInput = {
    where: documentsScalarWhereInput
    data: XOR<documentsUpdateManyMutationInput, documentsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type project_teamsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: project_teamsWhereUniqueInput
    update: XOR<project_teamsUpdateWithoutProjectsInput, project_teamsUncheckedUpdateWithoutProjectsInput>
    create: XOR<project_teamsCreateWithoutProjectsInput, project_teamsUncheckedCreateWithoutProjectsInput>
  }

  export type project_teamsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: project_teamsWhereUniqueInput
    data: XOR<project_teamsUpdateWithoutProjectsInput, project_teamsUncheckedUpdateWithoutProjectsInput>
  }

  export type project_teamsUpdateManyWithWhereWithoutProjectsInput = {
    where: project_teamsScalarWhereInput
    data: XOR<project_teamsUpdateManyMutationInput, project_teamsUncheckedUpdateManyWithoutProjectsInput>
  }

  export type clientsUpsertWithoutProjectsInput = {
    update: XOR<clientsUpdateWithoutProjectsInput, clientsUncheckedUpdateWithoutProjectsInput>
    create: XOR<clientsCreateWithoutProjectsInput, clientsUncheckedCreateWithoutProjectsInput>
    where?: clientsWhereInput
  }

  export type clientsUpdateToOneWithWhereWithoutProjectsInput = {
    where?: clientsWhereInput
    data: XOR<clientsUpdateWithoutProjectsInput, clientsUncheckedUpdateWithoutProjectsInput>
  }

  export type clientsUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client_pics?: client_picsUpdateManyWithoutClientsNestedInput
    documents?: documentsUpdateManyWithoutClientsNestedInput
  }

  export type clientsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    masked_description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    npwp?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client_pics?: client_picsUncheckedUpdateManyWithoutClientsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutClientsNestedInput
  }

  export type project_team_membersCreateWithoutRole_levelsInput = {
    job_description?: string | null
    end_at?: Date | string | null
    employees: employeesCreateNestedOneWithoutProject_team_membersInput
    project_teams: project_teamsCreateNestedOneWithoutProject_team_membersInput
  }

  export type project_team_membersUncheckedCreateWithoutRole_levelsInput = {
    id?: number
    project_teams_id: number
    job_description?: string | null
    end_at?: Date | string | null
    employee_id: number
  }

  export type project_team_membersCreateOrConnectWithoutRole_levelsInput = {
    where: project_team_membersWhereUniqueInput
    create: XOR<project_team_membersCreateWithoutRole_levelsInput, project_team_membersUncheckedCreateWithoutRole_levelsInput>
  }

  export type project_team_membersCreateManyRole_levelsInputEnvelope = {
    data: project_team_membersCreateManyRole_levelsInput | project_team_membersCreateManyRole_levelsInput[]
    skipDuplicates?: boolean
  }

  export type project_team_membersUpsertWithWhereUniqueWithoutRole_levelsInput = {
    where: project_team_membersWhereUniqueInput
    update: XOR<project_team_membersUpdateWithoutRole_levelsInput, project_team_membersUncheckedUpdateWithoutRole_levelsInput>
    create: XOR<project_team_membersCreateWithoutRole_levelsInput, project_team_membersUncheckedCreateWithoutRole_levelsInput>
  }

  export type project_team_membersUpdateWithWhereUniqueWithoutRole_levelsInput = {
    where: project_team_membersWhereUniqueInput
    data: XOR<project_team_membersUpdateWithoutRole_levelsInput, project_team_membersUncheckedUpdateWithoutRole_levelsInput>
  }

  export type project_team_membersUpdateManyWithWhereWithoutRole_levelsInput = {
    where: project_team_membersScalarWhereInput
    data: XOR<project_team_membersUpdateManyMutationInput, project_team_membersUncheckedUpdateManyWithoutRole_levelsInput>
  }

  export type documentsCreateManyClient_picsInput = {
    id?: number
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    project_id: number
    client_id: number
  }

  export type documentsUpdateWithoutClient_picsInput = {
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: clientsUpdateOneRequiredWithoutDocumentsNestedInput
    projects?: projectsUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type documentsUncheckedUpdateWithoutClient_picsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type documentsUncheckedUpdateManyWithoutClient_picsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type client_picsCreateManyClientsInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    project_id: number
  }

  export type documentsCreateManyClientsInput = {
    id?: number
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    project_id: number
    client_pic_id: number
  }

  export type projectsCreateManyClientsInput = {
    id?: number
    project_name: string
    project_code: string
    project_type: $Enums.project_types
    contract_value?: Decimal | DecimalJsLike | number | string | null
    started_at?: Date | string | null
    finished_at?: Date | string | null
    deleted_at?: Date | string | null
    is_deleted?: boolean | null
  }

  export type client_picsUpdateWithoutClientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: projectsUpdateOneRequiredWithoutClient_picsNestedInput
    documents?: documentsUpdateManyWithoutClient_picsNestedInput
  }

  export type client_picsUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    documents?: documentsUncheckedUpdateManyWithoutClient_picsNestedInput
  }

  export type client_picsUncheckedUpdateManyWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
  }

  export type documentsUpdateWithoutClientsInput = {
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    client_pics?: client_picsUpdateOneRequiredWithoutDocumentsNestedInput
    projects?: projectsUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type documentsUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_pic_id?: IntFieldUpdateOperationsInput | number
  }

  export type documentsUncheckedUpdateManyWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    client_pic_id?: IntFieldUpdateOperationsInput | number
  }

  export type projectsUpdateWithoutClientsInput = {
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_pics?: client_picsUpdateManyWithoutProjectsNestedInput
    documents?: documentsUpdateManyWithoutProjectsNestedInput
    project_teams?: project_teamsUpdateManyWithoutProjectsNestedInput
  }

  export type projectsUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    client_pics?: client_picsUncheckedUpdateManyWithoutProjectsNestedInput
    documents?: documentsUncheckedUpdateManyWithoutProjectsNestedInput
    project_teams?: project_teamsUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type projectsUncheckedUpdateManyWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_name?: StringFieldUpdateOperationsInput | string
    project_code?: StringFieldUpdateOperationsInput | string
    project_type?: Enumproject_typesFieldUpdateOperationsInput | $Enums.project_types
    contract_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finished_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type project_team_membersCreateManyEmployeesInput = {
    id?: number
    role_id: number
    project_teams_id: number
    job_description?: string | null
    end_at?: Date | string | null
  }

  export type project_teamsCreateManyEmployees_project_teams_auditor_idToemployeesInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    manager_id: number
    project_id: number
  }

  export type project_teamsCreateManyEmployees_project_teams_manager_idToemployeesInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    auditor_id?: number | null
    project_id: number
  }

  export type project_team_membersUpdateWithoutEmployeesInput = {
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_teams?: project_teamsUpdateOneRequiredWithoutProject_team_membersNestedInput
    role_levels?: role_levelsUpdateOneRequiredWithoutProject_team_membersNestedInput
  }

  export type project_team_membersUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    project_teams_id?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type project_team_membersUncheckedUpdateManyWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    project_teams_id?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type project_teamsUpdateWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    project_team_members?: project_team_membersUpdateManyWithoutProject_teamsNestedInput
    employees_project_teams_manager_idToemployees?: employeesUpdateOneRequiredWithoutProject_teams_project_teams_manager_idToemployeesNestedInput
    projects?: projectsUpdateOneRequiredWithoutProject_teamsNestedInput
  }

  export type project_teamsUncheckedUpdateWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    manager_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    project_team_members?: project_team_membersUncheckedUpdateManyWithoutProject_teamsNestedInput
  }

  export type project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_auditor_idToemployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    manager_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
  }

  export type project_teamsUpdateWithoutEmployees_project_teams_manager_idToemployeesInput = {
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    project_team_members?: project_team_membersUpdateManyWithoutProject_teamsNestedInput
    employees_project_teams_auditor_idToemployees?: employeesUpdateOneWithoutProject_teams_project_teams_auditor_idToemployeesNestedInput
    projects?: projectsUpdateOneRequiredWithoutProject_teamsNestedInput
  }

  export type project_teamsUncheckedUpdateWithoutEmployees_project_teams_manager_idToemployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    auditor_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: IntFieldUpdateOperationsInput | number
    project_team_members?: project_team_membersUncheckedUpdateManyWithoutProject_teamsNestedInput
  }

  export type project_teamsUncheckedUpdateManyWithoutEmployees_project_teams_manager_idToemployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    auditor_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: IntFieldUpdateOperationsInput | number
  }

  export type project_team_membersCreateManyProject_teamsInput = {
    id?: number
    role_id: number
    job_description?: string | null
    end_at?: Date | string | null
    employee_id: number
  }

  export type project_team_membersUpdateWithoutProject_teamsInput = {
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: employeesUpdateOneRequiredWithoutProject_team_membersNestedInput
    role_levels?: role_levelsUpdateOneRequiredWithoutProject_team_membersNestedInput
  }

  export type project_team_membersUncheckedUpdateWithoutProject_teamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type project_team_membersUncheckedUpdateManyWithoutProject_teamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type client_picsCreateManyProjectsInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    client_id: number
  }

  export type documentsCreateManyProjectsInput = {
    id?: number
    document_types?: $Enums.document_types | null
    number: string
    date_created?: Date | string | null
    date_signed?: Date | string | null
    document_url?: string | null
    client_pic_id: number
    client_id: number
  }

  export type project_teamsCreateManyProjectsInput = {
    id?: number
    project_teams_name: string
    project_teams_email: string
    manager_id: number
    auditor_id?: number | null
  }

  export type client_picsUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: clientsUpdateOneRequiredWithoutClient_picsNestedInput
    documents?: documentsUpdateManyWithoutClient_picsNestedInput
  }

  export type client_picsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: IntFieldUpdateOperationsInput | number
    documents?: documentsUncheckedUpdateManyWithoutClient_picsNestedInput
  }

  export type client_picsUncheckedUpdateManyWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type documentsUpdateWithoutProjectsInput = {
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: clientsUpdateOneRequiredWithoutDocumentsNestedInput
    client_pics?: client_picsUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type documentsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    client_pic_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type documentsUncheckedUpdateManyWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_types?: NullableEnumdocument_typesFieldUpdateOperationsInput | $Enums.document_types | null
    number?: StringFieldUpdateOperationsInput | string
    date_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_signed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_url?: NullableStringFieldUpdateOperationsInput | string | null
    client_pic_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
  }

  export type project_teamsUpdateWithoutProjectsInput = {
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    project_team_members?: project_team_membersUpdateManyWithoutProject_teamsNestedInput
    employees_project_teams_auditor_idToemployees?: employeesUpdateOneWithoutProject_teams_project_teams_auditor_idToemployeesNestedInput
    employees_project_teams_manager_idToemployees?: employeesUpdateOneRequiredWithoutProject_teams_project_teams_manager_idToemployeesNestedInput
  }

  export type project_teamsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    manager_id?: IntFieldUpdateOperationsInput | number
    auditor_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_team_members?: project_team_membersUncheckedUpdateManyWithoutProject_teamsNestedInput
  }

  export type project_teamsUncheckedUpdateManyWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_name?: StringFieldUpdateOperationsInput | string
    project_teams_email?: StringFieldUpdateOperationsInput | string
    manager_id?: IntFieldUpdateOperationsInput | number
    auditor_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type project_team_membersCreateManyRole_levelsInput = {
    id?: number
    project_teams_id: number
    job_description?: string | null
    end_at?: Date | string | null
    employee_id: number
  }

  export type project_team_membersUpdateWithoutRole_levelsInput = {
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employees?: employeesUpdateOneRequiredWithoutProject_team_membersNestedInput
    project_teams?: project_teamsUpdateOneRequiredWithoutProject_team_membersNestedInput
  }

  export type project_team_membersUncheckedUpdateWithoutRole_levelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_id?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type project_team_membersUncheckedUpdateManyWithoutRole_levelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_teams_id?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    end_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}